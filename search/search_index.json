{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"openEO by TiTiler","text":"<p>TiTiler backend for openEO</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>openEO by TiTiler is a TiTiler backend implementation for openEO developed by  and .</p> <p>The main goal of this project is to provide a light and fast backend for openEO services and processes using the TiTiler engine. This simplicity comes with some specific implementation choices like the type of data managed by the backend. It is focused on image raster data that can be processed on-the-fly and served as tiles or as light dynamic raw data. For more details about the implementation choices, see the Concepts section.</p> <p>The application implements the openEO API (L1A and L1C) profiles.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>STAC API integration with external STAC services</li> <li>Synchronous processing capabilities</li> <li>Various output formats (e.g., JPEG, PNG)</li> <li>Multiple supported processes</li> <li>Dynamic tiling services</li> <li>FastAPI-based application</li> <li>Middleware for CORS, compression, and caching</li> <li>Optimized RasterStack data model for consistent processing with datetime keys</li> <li>Lazy loading with ImageRef for improved performance</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For installation and setup instructions, see:</p> <ul> <li>Local Setup for development environment</li> <li>Kubernetes Guide for production deployment</li> <li>Administrator Guide for configuration options</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Project: Overview and release notes</li> <li>Architecture: Core concepts and data models</li> <li>Deployment: Installation and configuration guides</li> <li>Development: Contributing guidelines</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#authors","title":"Authors","text":"<p>Created by Development Seed and Sinergise.</p> <p>See contributors for a listing of individual contributors.</p>"},{"location":"admin-guide/","title":"Administrator Guide","text":"<p>This guide provides information for system administrators managing an openEO by TiTiler deployment. The implementation details can be found in the codebase, particularly in <code>titiler/openeo/settings.py</code> for configuration options.</p>"},{"location":"admin-guide/#system-requirements","title":"System Requirements","text":""},{"location":"admin-guide/#environment-variables","title":"Environment Variables","text":"<p>openEO by TiTiler is configured through environment variables. Key configuration areas include:</p>"},{"location":"admin-guide/#api-settings-apisettings","title":"API Settings (<code>ApiSettings</code>)","text":"<pre><code>TITILER_OPENEO_API_NAME=\"openEO by TiTiler\"\nTITILER_OPENEO_API_CORS_ORIGINS=\"*\"\nTITILER_OPENEO_API_CORS_ALLOW_METHODS=\"GET,POST,PUT,PATCH,DELETE,OPTIONS\"\nTITILER_OPENEO_API_ROOT_PATH=\"\"\nTITILER_OPENEO_API_DEBUG=false\n</code></pre>"},{"location":"admin-guide/#backend-settings-backendsettings","title":"Backend Settings (<code>BackendSettings</code>)","text":"<pre><code>TITILER_OPENEO_STAC_API_URL=\"https://your-stac-api\"\nTITILER_OPENEO_STORE_URL=\"path-to-services-config\"\nTITILER_OPENEO_TILE_STORE_URL=\"optional-tile-store-url\"\n</code></pre>"},{"location":"admin-guide/#processing-settings-processingsettings","title":"Processing Settings (<code>ProcessingSettings</code>)","text":"<pre><code>TITILER_OPENEO_PROCESSING_MAX_PIXELS=100000000\nTITILER_OPENEO_PROCESSING_MAX_ITEMS=20\n</code></pre>"},{"location":"admin-guide/#cache-settings-cachesettings","title":"Cache Settings (<code>CacheSettings</code>)","text":"<pre><code>TITILER_OPENEO_CACHE_TTL=300\nTITILER_OPENEO_CACHE_MAXSIZE=512\nTITILER_OPENEO_CACHE_DISABLE=false\n</code></pre>"},{"location":"admin-guide/#authentication","title":"Authentication","text":"<p>openEO by TiTiler supports two authentication methods:</p> <ol> <li>Basic Authentication (default)</li> <li>Configured through <code>AuthSettings</code></li> <li>Set <code>TITILER_OPENEO_AUTH_METHOD=basic</code></li> <li> <p>Configure users in environment:</p> <pre><code>TITILER_OPENEO_AUTH_USERS='{\"user1\": {\"password\": \"pass1\", \"roles\": [\"user\"]}}'\n</code></pre> </li> <li> <p>OpenID Connect</p> </li> <li>See OpenID Connect Configuration for details</li> </ol>"},{"location":"admin-guide/#performance-tuning","title":"Performance Tuning","text":""},{"location":"admin-guide/#cache-configuration","title":"Cache Configuration","text":"<p>The caching system can be tuned through the following settings:</p> <ul> <li><code>TITILER_OPENEO_CACHE_TTL</code>: Time-to-live for cached items (seconds)</li> <li><code>TITILER_OPENEO_CACHE_MAXSIZE</code>: Maximum number of items in cache</li> <li><code>TITILER_OPENEO_CACHE_DISABLE</code>: Disable caching entirely</li> </ul>"},{"location":"admin-guide/#processing-limits","title":"Processing Limits","text":"<p>To prevent resource exhaustion:</p> <ul> <li><code>TITILER_OPENEO_PROCESSING_MAX_PIXELS</code>: Maximum allowed pixels for image processing</li> <li><code>TITILER_OPENEO_PROCESSING_MAX_ITEMS</code>: Maximum number of items (STAC items from a API search) in a request</li> </ul>"},{"location":"admin-guide/#monitoring","title":"Monitoring","text":""},{"location":"admin-guide/#api-endpoints","title":"API Endpoints","text":"<p>The application provides several endpoints for monitoring:</p> <ul> <li><code>/health</code>: Health check endpoint</li> <li><code>/docs</code>: OpenAPI documentation</li> <li><code>/redoc</code>: Alternative API documentation</li> </ul>"},{"location":"admin-guide/#logging","title":"Logging","text":"<p>Logging configuration is managed through <code>log_config.yaml</code>. The default configuration includes:</p> <ul> <li>Console output</li> <li>JSON formatting</li> <li>Different log levels for different components</li> </ul>"},{"location":"admin-guide/#security","title":"Security","text":""},{"location":"admin-guide/#cors-configuration","title":"CORS Configuration","text":"<p>Configure CORS settings through:</p> <pre><code>TITILER_OPENEO_API_CORS_ORIGINS=\"domain1.com,domain2.com\"\nTITILER_OPENEO_API_CORS_ALLOW_METHODS=\"GET,POST,PUT,PATCH,DELETE,OPTIONS\"\n</code></pre>"},{"location":"admin-guide/#cache-control","title":"Cache Control","text":"<p>Configure cache control headers:</p> <pre><code>TITILER_OPENEO_API_CACHE_STATIC=\"public, max-age=3600\"\nTITILER_OPENEO_API_CACHE_TILES=\"public, max-age=3600\"\nTITILER_OPENEO_API_CACHE_DYNAMIC=\"no-cache\"\nTITILER_OPENEO_API_CACHE_DEFAULT=\"no-store\"\n</code></pre> <ul> <li><code>CACHE_STATIC</code>: For static resources like CSS, JS files</li> <li><code>CACHE_TILES</code>: For XYZ tile endpoints (<code>/services/xyz/</code>), allowing browsers to cache tiles</li> <li><code>CACHE_DYNAMIC</code>: For dynamic API endpoints that need fresh data</li> <li><code>CACHE_DEFAULT</code>: Default policy for other endpoints</li> </ul>"},{"location":"admin-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"admin-guide/#common-issues","title":"Common Issues","text":"<ol> <li>Authentication Failures</li> <li>Check authentication method configuration</li> <li>Verify user credentials or OIDC settings</li> <li> <p>Check token format and expiration</p> </li> <li> <p>Performance Issues</p> </li> <li>Review cache settings</li> <li>Check processing limits</li> <li> <p>Monitor system resources</p> </li> <li> <p>CORS Issues</p> </li> <li>Verify CORS origins configuration</li> <li>Check allowed methods</li> <li>Review client requests</li> </ol>"},{"location":"admin-guide/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode for detailed logging:</p> <pre><code>TITILER_OPENEO_API_DEBUG=true\n</code></pre>"},{"location":"admin-guide/#maintenance","title":"Maintenance","text":""},{"location":"admin-guide/#backup-considerations","title":"Backup Considerations","text":"<ol> <li>Configuration</li> <li>Environment variables</li> <li>Service configurations</li> <li> <p>Authentication settings</p> </li> <li> <p>Data</p> </li> <li>Tile store data if used</li> <li>Cache contents if persistent</li> </ol>"},{"location":"admin-guide/#updates","title":"Updates","text":"<p>When updating openEO by TiTiler:</p> <ol> <li>Review the changelog</li> <li>Backup configuration</li> <li>Test in a staging environment</li> <li>Plan for downtime if needed</li> <li>Update the application</li> <li>Verify functionality</li> </ol> <p>For implementation details, refer to the source code.</p>"},{"location":"authorization/","title":"Service Authorization","text":"<p>TiTiler OpenEO implements a flexible service authorization mechanism that controls access to services based on their configuration. Each service can be configured with different access levels through the <code>scope</code> parameter.</p>"},{"location":"authorization/#scopes","title":"Scopes","text":"<p>Services can be configured with one of three scopes:</p> <ul> <li><code>private</code>: Only the service owner can access the service</li> <li><code>restricted</code>: Any authenticated user can access, with optional user-specific restrictions</li> <li><code>public</code> (default): No authentication required, anyone can access the service</li> </ul>"},{"location":"authorization/#configuration","title":"Configuration","text":"<p>Authorization is configured through the service configuration object when creating or updating a service:</p> <pre><code>{\n  \"configuration\": {\n    \"scope\": \"restricted\",\n    \"authorized_users\": [\"user1\", \"user2\"]  // Optional: specific users for restricted scope\n  }\n}\n</code></pre>"},{"location":"authorization/#configuration-parameters","title":"Configuration Parameters","text":"Parameter Type Description <code>scope</code> string Access scope: <code>private</code>, <code>restricted</code>, or <code>public</code> <code>authorized_users</code> array Optional list of user IDs allowed to access a restricted service"},{"location":"authorization/#implementation","title":"Implementation","text":"<p>The authorization mechanism is implemented in two main components:</p> <ol> <li><code>ServiceAuthorizationManager</code> class (<code>titiler/openeo/services/auth.py</code>):</li> <li>Encapsulates authorization logic</li> <li>Validates access based on service configuration and user context</li> <li> <p>Throws appropriate HTTP exceptions for unauthorized access</p> </li> <li> <p>Service endpoints:</p> </li> <li>Retrieve service configuration</li> <li>Use ServiceAuthorizationManager to enforce access control</li> <li>Pass authorized requests to the service implementation</li> </ol>"},{"location":"authorization/#example-usage","title":"Example Usage","text":"<p>For example:</p> <pre><code>{\n  \"configuration\": {\n    \"scope\": \"restricted\",\n    \"authorized_users\": [\"user1\", \"user2\"],\n  }\n}\n</code></pre> <p>The behavior of the injected user parameter depends on how it's defined in the process's JSON schema:</p> <ol> <li>When the parameter schema defines <code>\"type\": \"string\"</code>:</li> </ol> <pre><code>{\n  \"parameters\": {\n    \"user_id\": {\n      \"type\": \"string\",\n      \"description\": \"User identifier\"\n    }\n  }\n}\n</code></pre> <p>The process will receive just the user ID string, even when using from_parameter:</p> <pre><code>{\n  \"process_graph\": {\n    \"example1\": {\n      \"process_id\": \"example_process\",\n      \"arguments\": {\n        \"user_id\": {\n          \"from_parameter\": \"_openeo_user\"  // Will extract just the user_id\n        }\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>When the parameter schema defines a User object type:</li> </ol> <pre><code>{\n  \"parameters\": {\n    \"user\": {\n      \"type\": \"object\",\n      \"description\": \"User object with full properties\"\n    }\n  }\n}\n</code></pre> <p>The process will receive the complete User object:</p> <pre><code>{\n  \"process_graph\": {\n    \"example1\": {\n      \"process_id\": \"example_process\",\n      \"arguments\": {\n        \"user\": {\n          \"from_parameter\": \"_openeo_user\"  // Will provide the full User object\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>from titiler.openeo.services.auth import ServiceAuthorizationManager\n\n# In your service endpoint:\nservice = services_store.get_service(service_id)\nauth_manager = ServiceAuthorizationManager()\nauth_manager.authorize(service, user)  # Raises HTTPException if access denied\n</code></pre>"},{"location":"authorization/#authorization-flow","title":"Authorization Flow","text":"<ol> <li>Client requests a service endpoint</li> <li>Service configuration is retrieved from the store</li> <li>ServiceAuthorizationManager validates access based on:</li> <li>Service scope</li> <li>User authentication status</li> <li>User authorization (for restricted services)</li> <li>If access is denied:</li> <li>401 Unauthorized - For missing authentication</li> <li>403 Forbidden - For insufficient permissions</li> <li>If access is granted, the request proceeds to service execution</li> </ol>"},{"location":"authorization/#user-injection","title":"User Injection","text":"<p>If the service call is authenticated, the authenticated user will be injected into the process graph as a named parameter <code>_openeo_user</code>. Thus any process graph parameter can reference the authenticated user by using <code>from_parameter: \"_openeo_user\"</code>.</p>"},{"location":"authorization/#best-practices","title":"Best Practices","text":"<ol> <li>Always set an appropriate scope for your services</li> <li>Use <code>private</code> scope by default for maximum security</li> <li>For restricted services, explicitly list authorized users</li> <li>Consider using <code>public</code> scope only for non-sensitive data</li> <li>Regularly audit service configurations and access patterns</li> </ol>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This document explains the core concepts and data models used in openEO by TiTiler.</p>"},{"location":"concepts/#data-model","title":"Data Model","text":"<p>In openEO, a datacube is a fundamental concept and a key component of the platform. While traditional openEO implementations use multi-dimensional arrays for data representation, openEO by TiTiler simplifies this concept by focusing on image raster data that can be processed on-the-fly and served as tiles or as light dynamic raw data.</p>"},{"location":"concepts/#resolution-and-dimension-management","title":"Resolution and Dimension Management","text":"<p>The backend intelligently handles resolution and dimensions using these key principles:</p> <ol> <li>Default Resolution Control:</li> <li>The <code>load_collection</code> process defaults to a width of 1024 pixels</li> <li>This intentionally avoids loading data at native resolution by default, which could cause memory issues</li> <li>Users can explicitly request native resolution by providing their own width/height parameters</li> <li> <p>The default provides a good balance between quality and performance</p> </li> <li> <p>Native Resolution Access:</p> </li> <li>Resolution information is extracted from source metadata (transform or shape)</li> <li>When width/height parameters are provided, proportions are maintained</li> <li> <p>Resolution is adjusted based on the requested spatial extent</p> </li> <li> <p>Early Resolution Optimization:</p> </li> <li>Resolution is determined during initial data loading</li> <li>Cropping adjusts resolution proportionally</li> <li>CRS reprojection accounts for resolution changes</li> </ol>"},{"location":"concepts/#crs-management-and-the-target_crs-parameter","title":"CRS Management and the <code>target_crs</code> Parameter","text":"<p>openEO by TiTiler is designed primarily for tiling applications, where data needs to be served efficiently through XYZ tile endpoints. This context strongly influences how Coordinate Reference Systems (CRS) are handled.</p>"},{"location":"concepts/#tile-centric-crs-design","title":"Tile-Centric CRS Design","text":"<p>When serving tiles, the output CRS is determined by the Tile Matrix Set (TMS) being used\u2014typically Web Mercator (EPSG:3857) for web mapping. This means:</p> <ul> <li>XYZ Tile Endpoints: Always reproject data to match the TMS CRS automatically</li> <li>Process Graph Endpoints: Can preserve native CRS or use explicit <code>target_crs</code></li> <li>Resolution Units: Match the CRS being used (meters for UTM/Web Mercator, degrees for EPSG:4326)</li> </ul>"},{"location":"concepts/#the-target_crs-parameter","title":"The <code>target_crs</code> Parameter","text":"<p>The <code>load_collection</code> process accepts a <code>target_crs</code> parameter that controls the output CRS independently of the bounding box CRS:</p> <code>target_crs</code> Value Behavior <code>null</code> (default) Preserve the native CRS from the source images EPSG code (e.g., <code>32632</code>) Reproject output to that CRS WKT2 string Reproject output to the specified CRS <p>Important distinction: The <code>spatial_extent</code> defines where to load data (bbox coordinates), while <code>target_crs</code> defines what CRS the output should be in:</p> <pre><code>{\n  \"process_id\": \"load_collection\",\n  \"arguments\": {\n    \"id\": \"sentinel-2-l2a\",\n    \"spatial_extent\": {\n      \"west\": 10.0,\n      \"east\": 11.0,\n      \"south\": 45.0,\n      \"north\": 46.0,\n      \"crs\": 4326\n    },\n    \"target_crs\": null\n  }\n}\n</code></pre> <p>In this example:</p> <ul> <li>The bbox is interpreted in EPSG:4326 (lat/lon degrees)</li> <li>The output preserves the native CRS of the source data (e.g., UTM zone 32N for Sentinel-2)</li> </ul>"},{"location":"concepts/#resolution-and-crs-interaction","title":"Resolution and CRS Interaction","text":"<p>When specifying resolution in meters (e.g., <code>resample_spatial</code> with <code>resolution: 100</code>), the CRS must be in a projected coordinate system where units are meters:</p> CRS Type Resolution Interpretation UTM (e.g., EPSG:32632) 100 = 100 meters Web Mercator (EPSG:3857) 100 = ~100 meters (with distortion at higher latitudes) WGS84 (EPSG:4326) 100 = 100 degrees (incorrect for most use cases!) <p>Best Practice: When using <code>resample_spatial</code> with meter-based resolution, ensure <code>target_crs</code> is set to a projected CRS or left as <code>null</code> to preserve the native projected CRS of the source data.</p>"},{"location":"concepts/#xyz-tile-endpoint-behavior","title":"XYZ Tile Endpoint Behavior","text":"<p>The XYZ tile endpoint automatically sets <code>target_crs</code> to match the Tile Matrix Set's CRS:</p> <pre><code>GET /xyz/{z}/{x}/{y}.png?process=...\n</code></pre> <p>This ensures tiles are served in the correct projection regardless of what <code>target_crs</code> is specified in the process graph. The tile endpoint overrides <code>target_crs</code> with <code>tms.crs</code> (typically Web Mercator).</p>"},{"location":"concepts/#raster-data-model","title":"Raster Data Model","text":"<p>The backend uses three primary data structures for efficient processing:</p> <ol> <li>ImageData: Most processes use <code>ImageData</code> objects provided by rio-tiler for individual raster operations. This object was initially designed to create slippy map tiles from large raster data sources and render these tiles dynamically on a web map. Each ImageData object inherently has two spatial dimensions (height and width).</li> </ol> <p></p> <ol> <li>RasterStack: A dictionary mapping names/dates to ImageData objects, allowing for consistent handling of multiple raster layers. This is our implementation of the openEO data cube concept, with some key characteristics:</li> <li>An empty data cube is represented as an empty dictionary (<code>{}</code>)</li> <li>When there is at least one raster in the stack, it has a minimum of 2 dimensions (the spatial dimensions from the raster data)</li> <li>Additional dimensions (like temporal or bands) can be added, but they must be compatible with the existing spatial dimensions</li> <li> <p>Spatial dimensions are inherent to the raster data and cannot be added separately</p> </li> <li> <p>LazyRasterStack: An optimized version of RasterStack that lazily loads data when accessed. This improves performance by only executing processing tasks when the data is actually needed. The enhanced implementation includes:</p> </li> <li>Temporal Intelligence: Automatic organization and grouping of data by timestamps</li> <li>Concurrent Execution: Parallel data loading using ThreadPoolExecutor for improved performance  </li> <li>Timestamp-based Access: Direct access to observations by time periods for efficient time-series analysis</li> <li>Multi-dimensional Support: Explicit handling of time and spectral dimensions</li> </ol>"},{"location":"concepts/#dimension-handling","title":"Dimension Handling","text":"<p>The data cube implementation in openEO by TiTiler follows these principles for dimension handling:</p> <ol> <li> <p>Spatial Dimensions: Every raster in the stack has two spatial dimensions (height and width) that are inherent to the data. These dimensions cannot be added or removed through processes, as they are fundamental to the raster data structure.</p> </li> <li> <p>Additional Dimensions: Non-spatial dimensions can be added to the data cube:</p> </li> <li>Temporal dimension: For time series data organized by timestamps (e.g., datetime objects for satellite observations)</li> <li>Bands dimension: For spectral bands within each temporal observation (e.g., \"red\", \"green\", \"blue\", \"nir\")</li> <li> <p>Other dimensions: For any other type of categorization</p> </li> <li> <p>Enhanced Temporal Support: The RasterStack model now provides first-class support for the temporal dimension:</p> </li> <li>Time-first Organization: RasterStack keys represent temporal observations, with each containing multi-band ImageData</li> <li>Temporal Grouping: Automatic grouping and sorting of observations by timestamp</li> <li>Concurrent Processing: Parallel loading of observations within the same time period</li> <li> <p>Dimension-aware Operations: Processes can operate specifically on temporal or spectral dimensions</p> </li> <li> <p>Dimension Compatibility: When adding dimensions to a non-empty data cube, the new dimension must be compatible with the existing spatial dimensions. This means any ImageData added to the stack must match the height and width of existing rasters.</p> </li> <li> <p>Empty Data Cubes: An empty data cube (<code>{}</code>) can receive any non-spatial dimension. The first raster data added to the cube will establish the spatial dimensions that all subsequent data must match.</p> </li> </ol>"},{"location":"concepts/#data-reduction","title":"Data Reduction","text":"<p>The ImageData object is obtained by reducing as early as possible the data from the collections. The recommended approach is to use <code>load_collection</code> followed by <code>reduce_dimension</code> with dimension <code>'time'</code> (or <code>'temporal'</code>). This approach:</p> <ol> <li>Uses a default width of 1024 pixels to prevent memory issues</li> <li>Allows explicit control over resolution through width/height parameters</li> <li>Performs data reduction at the target resolution</li> <li>Maintains proper proportions throughout the process</li> <li>Provides more flexibility for custom reducers and dimension handling</li> </ol> <p>Note: The <code>load_collection_and_reduce</code> process is deprecated and maintained only for backward compatibility.</p> <p></p> <p>The reduce process includes a parameter to choose the pixel selection method:</p> <ul> <li><code>first</code> (default): selects the first pixel value</li> <li><code>highest</code>, <code>lowest</code>: selects extreme values</li> <li><code>mean</code>, <code>median</code>, <code>stddev</code>: statistical measures</li> <li><code>lastbandlow</code>, <code>lastbandhigh</code>, <code>lastbandavg</code>: band-specific selections</li> <li><code>count</code>: number of valid pixels</li> </ul>"},{"location":"concepts/#collections-and-stac-integration","title":"Collections and STAC Integration","text":"<p>openEO by TiTiler integrates with external STAC API services to provide collections. It uses <code>pystac-client</code> to proxy the STAC API, configured through the <code>TITILER_OPENEO_STORE_URL</code> environment variable.</p>"},{"location":"concepts/#openeo-process-graph-to-cql2-json-conversion","title":"OpenEO Process Graph to CQL2-JSON Conversion","text":"<p>The backend automatically converts OpenEO process graphs to CQL2-JSON format for STAC API filtering. Supported operators include:</p> <ul> <li>Comparison operators (<code>eq</code>, <code>neq</code>, <code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code>, <code>between</code>)</li> <li>Array operators (<code>in</code>, <code>array_contains</code>)</li> <li>Pattern matching operators (<code>starts_with</code>, <code>ends_with</code>, <code>contains</code>)</li> <li>Null checks (<code>is_null</code>)</li> <li>Logical operators (<code>and</code>, <code>or</code>, <code>not</code>)</li> </ul> <p>Example conversion:</p> <pre><code>// OpenEO process graph\n{\n  \"cloud_cover\": {\n    \"process_graph\": {\n      \"cc\": {\n        \"process_id\": \"lt\",\n        \"arguments\": {\"x\": {\"from_parameter\": \"value\"}, \"y\": 20}\n      }\n    }\n  }\n}\n\n// Converted to CQL2-JSON\n{\n  \"op\": \"&lt;\",\n  \"args\": [{\"property\": \"properties.cloud_cover\"}, 20]\n}\n</code></pre>"},{"location":"concepts/#performance-considerations","title":"Performance Considerations","text":"<p>The backend is optimized for on-the-fly processing and serving of raster data. Key considerations:</p> <ul> <li>Processing time increases with the extent of data</li> <li>Larger extents may lead to timeouts</li> <li>The backend can be easily replicated and scaled</li> <li>No additional middleware required for deployment</li> <li>Resolution is managed automatically to balance quality and performance</li> <li>Memory usage is controlled through:</li> <li>Default width of 1024 pixels in load functions</li> <li>Pixel count limits for larger requests</li> <li>Early resolution optimization</li> </ul>"},{"location":"concepts/#parameter-management","title":"Parameter Management","text":"<p>The backend supports comprehensive parameter management for dynamic process graph execution. Parameters can be:</p> <ul> <li>Defined with default values in process graph definitions</li> <li>Overridden via query parameters in API requests where supported (e.g., <code>/result</code> endpoint or secondary tile services)</li> <li>Automatically injected by the system (user context, spatial boundaries for tiles)</li> <li>Validated against schema definitions</li> </ul> <p>For detailed information about parameter handling, query parameter syntax, default value resolution, and breaking changes, see the Parameter Management documentation.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/sentinel-hub/titiler-openeo/issues</p>"},{"location":"contributing/#local-environment","title":"Local environment","text":"<p>It is easiest to bootstrap a development environment with <code>uv</code>:</p> <pre><code>uv sync\ncp .env.eoapi .env\nexport $(cat .env | xargs)\nuvicorn titiler.openeo.main:app --host 0.0.0.0 --port 8081\n</code></pre>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black, and mypy when committing new code.</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre> <p>Add coverage options (e.g. <code>--cov=titiler.openeo</code>) when validating locally before release.</p>"},{"location":"contributing/#use-the-openeo-editor","title":"Use the openEO editor","text":"<p>To use the openEO editor, use Docker Compose to start all services:</p> <pre><code>docker compose up\n</code></pre> <p>This will start:</p> <ul> <li>API service at localhost:8081</li> <li>openEO Web Editor at localhost:8080</li> <li>Keycloak at localhost:8082</li> </ul> <p>Access the editor at localhost:8080 and set the backend URL to localhost:8081. For authentication setup and testing, see the Admin Guide.</p>"},{"location":"contributing/#authentication-testing-with-keycloak","title":"Authentication testing with Keycloak","text":"<p>The project includes a Keycloak instance for testing OpenID Connect authentication. After starting the stack with <code>docker compose up</code>, configure Keycloak as follows:</p> <ol> <li>Access the Keycloak admin console at localhost:8082/admin</li> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> <li>Create a new client:</li> <li>Go to \"Clients\" \u2192 \"Create client\"</li> <li>Client ID: <code>titiler-openeo</code></li> <li>Client type: <code>OpenID Connect</code></li> <li>Click \"Next\"</li> <li>Enable \"Client authentication\"</li> <li>Enable \"Authorization\"</li> <li>Click \"Save\"</li> <li>Configure client settings:</li> <li>Valid redirect URIs: <code>http://localhost:8080/*</code> for the openEO editor</li> <li>Web origins: <code>http://localhost:8080</code> for the openEO editor</li> <li>Click \"Save\"</li> </ol> <p>The environment includes several pre-configured settings:</p> <ul> <li>GDAL optimization settings for performance</li> <li>Debug mode enabled</li> <li>STAC API endpoint set to stac.eoapi.dev</li> <li> <p>Keycloak OIDC configuration</p> </li> <li> <p>Create a test user:</p> </li> <li>Go to \"Users\" \u2192 \"Add user\"</li> <li>Username: <code>test</code></li> <li>Email: <code>test@example.com</code></li> <li>Click \"Create\"</li> <li>Go to \"Credentials\" tab</li> <li>Set password: <code>test123</code></li> <li>Disable \"Temporary\"</li> <li>Click \"Save password\"</li> </ul> <p>The Keycloak server will be available at localhost:8082 for testing OIDC authentication flows.</p>"},{"location":"contributing/#docs","title":"Docs","text":"<p>Install the documentation dependencies (included in the dev group) with <code>uv</code>:</p> <pre><code>uv sync --group docs\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>To manually deploy docs (note you should never need to do this because GitHub Actions deploys automatically for new commits.):</p> <pre><code>mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre>"},{"location":"kubernetes/","title":"Kubernetes Deployment Guide","text":"<p>This guide explains how to deploy openEO by TiTiler on Kubernetes using Helm. The implementation is available in the <code>deployment/k8s</code> directory.</p>"},{"location":"kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes 1.16+</li> <li>Helm 3.0+</li> <li>PostgreSQL (optional, can be deployed as a subchart)</li> </ul>"},{"location":"kubernetes/#quick-start","title":"Quick Start","text":"<p>For local testing with Minikube:</p> <pre><code># Start Minikube\nminikube start\n\n# Set context\nkubectl config use-context minikube\n\n# Install using Helm\ncd deployment/k8s\nhelm upgrade --install openeo-titiler .\n\n# Enable ingress (if needed)\nminikube addons enable ingress\n\n# Get service URL\nminikube service ingress-nginx-controller -n ingress-nginx --url | head -n 1\n</code></pre>"},{"location":"kubernetes/#configuration","title":"Configuration","text":"<p>For detailed configuration options, refer to the Helm chart README. The README provides comprehensive documentation on:</p> <ul> <li>Global parameters</li> <li>Database configuration (JSON, DuckDB, PostgreSQL)</li> <li>Persistence settings</li> <li>Ingress configuration</li> <li>Resource management</li> <li>Autoscaling options</li> </ul>"},{"location":"kubernetes/#cdse-integration","title":"CDSE Integration","text":"<p>For deploying with Copernicus Data Space Ecosystem (CDSE), follow the instructions in the CDSE deployment section of the Helm chart documentation.</p>"},{"location":"kubernetes/#production-deployment-considerations","title":"Production Deployment Considerations","text":"<p>When deploying to production:</p> <ol> <li>Configure appropriate resource limits and requests</li> <li>Enable and configure persistent storage</li> <li>Set up proper ingress with TLS</li> <li>Configure authentication</li> <li>Tune environment variables for performance</li> <li>Enable monitoring and logging</li> </ol> <p>For specific configuration values and examples, refer to the configuration section in the Helm chart documentation.</p>"},{"location":"kubernetes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kubernetes/#common-issues","title":"Common Issues","text":"<ol> <li>Pod Startup Failures</li> <li>Check resource limits</li> <li>Verify storage configuration</li> <li> <p>Check logs: <code>kubectl logs -l app=openeo-titiler</code></p> </li> <li> <p>Database Connection Issues</p> </li> <li>Verify database configuration</li> <li>Check connectivity to external database</li> <li> <p>Validate persistent volume claims</p> </li> <li> <p>Ingress Problems</p> </li> <li>Verify ingress controller is running</li> <li>Check ingress configuration</li> <li>Validate TLS certificates</li> </ol> <p>For more details on configuration options and deployment scenarios, see the Helm chart documentation.</p>"},{"location":"local-setup/","title":"Local Setup","text":"<p>This guide explains how to set up openEO by TiTiler locally.</p>"},{"location":"local-setup/#installation","title":"Installation","text":"<p>Clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/sentinel-hub/titiler-openeo.git\ncd titiler-openeo\npython -m pip install -e .\n</code></pre>"},{"location":"local-setup/#configuration","title":"Configuration","text":""},{"location":"local-setup/#environment-setup","title":"Environment Setup","text":"<p>The application can be configured using different environment files:</p> <ol> <li>EOAPI Configuration (default)</li> </ol> <pre><code>cp .env.eoapi .env\nexport $(cat .env | xargs)\n</code></pre> <p>This sets up:</p> <pre><code>TITILER_OPENEO_STAC_API_URL=\"https://stac.eoapi.dev\"\nTITILER_OPENEO_STORE_URL=\"services/eoapi.json\"\n</code></pre> <ol> <li>CDSE Configuration</li> </ol> <pre><code>cp .env.cdse .env\nexport $(cat .env | xargs)\n</code></pre> <p>This configures:</p> <pre><code>TITILER_OPENEO_STAC_API_URL=\"https://stac.dataspace.copernicus.eu/v1\"\nTITILER_OPENEO_STORE_URL=\"services/copernicus.json\"\n</code></pre> <p>For CDSE, additional environment variables are required for efficient data access:</p> <pre><code>AWS_S3_ENDPOINT=eodata.dataspace.copernicus.eu\nAWS_ACCESS_KEY_ID=&lt;your_access_key&gt;\nAWS_SECRET_ACCESS_KEY=&lt;your_secret_key&gt;\nAWS_VIRTUAL_HOSTING=FALSE\nCPL_VSIL_CURL_CACHE_SIZE=200000000\nGDAL_HTTP_MULTIPLEX=TRUE\nGDAL_CACHEMAX=500\nGDAL_INGESTED_BYTES_AT_OPEN=50000\nGDAL_HTTP_MERGE_CONSECUTIVE_RANGES=YES\nVSI_CACHE_SIZE=5000000\nVSI_CACHE=TRUE\n</code></pre>"},{"location":"local-setup/#running-the-application","title":"Running the Application","text":"<p>Start the server:</p> <pre><code>uvicorn titiler.openeo.main:app --host 0.0.0.0 --port 8080\n</code></pre> <p>The API will be available at <code>http://localhost:8080</code></p>"},{"location":"local-setup/#using-the-openeo-editor","title":"Using the openEO Editor","text":"<p>To use the openEO Web Editor with your local instance:</p> <ol> <li>Start the openEO Web Editor:</li> </ol> <pre><code>docker pull mundialis/openeo-web-editor:latest\ndocker run -p 8081:80 mundialis/openeo-web-editor:latest\n</code></pre> <ol> <li> <p>Access the editor at <code>http://localhost:8081</code></p> </li> <li> <p>Configure the editor:</p> </li> <li>Set backend URL to <code>http://localhost:8080</code></li> <li>Login with the default basic auth credentials:<ul> <li>Username: <code>test</code></li> <li>Password: <code>test</code></li> </ul> </li> </ol>"},{"location":"migration-rasterstack/","title":"RasterStack Migration Guide","text":"<p>This guide helps you migrate from the old <code>LazyRasterStack</code> / type alias architecture to the new unified <code>RasterStack</code> class.</p>"},{"location":"migration-rasterstack/#summary-of-changes","title":"Summary of Changes","text":"<p>The RasterStack architecture has been simplified:</p> Before After <code>RasterStack = Dict[str, ImageData]</code> (type alias) <code>RasterStack</code> (class) inherits <code>Dict[datetime, ImageData]</code> <code>LazyRasterStack</code> (separate class) <code>RasterStack</code> (unified) <code>LazyImageRef</code> / <code>EagerImageRef</code> (two classes) <code>ImageRef</code> (unified, no <code>key</code> field) <code>key_fn</code> + <code>timestamp_fn</code> <code>timestamp_fn</code> only (datetime IS the key) <code>get_first_item()</code> / <code>get_last_item()</code> <code>.first</code> / <code>.last</code> properties <code>to_raster_stack()</code> <code>RasterStack.from_images()</code>"},{"location":"migration-rasterstack/#migration-steps","title":"Migration Steps","text":""},{"location":"migration-rasterstack/#1-update-imports","title":"1. Update Imports","text":"<pre><code># Before\nfrom titiler.openeo.processes.implementations.data_model import (\n    LazyRasterStack,\n    LazyImageRef,\n    to_raster_stack,\n    get_first_item,\n    get_last_item,\n)\n\n# After\nfrom titiler.openeo.processes.implementations.data_model import (\n    RasterStack,\n    ImageRef,\n)\n</code></pre>"},{"location":"migration-rasterstack/#2-replace-lazyrasterstack-with-rasterstack","title":"2. Replace LazyRasterStack with RasterStack","text":"<p>The <code>key_fn</code> parameter is no longer needed - the datetime returned by <code>timestamp_fn</code> is used directly as the key:</p> <pre><code># Before\nraster_stack = LazyRasterStack(\n    tasks=tasks,\n    key_fn=lambda asset: asset[\"id\"],\n    timestamp_fn=lambda asset: asset[\"datetime\"],\n)\n\n# After - timestamp IS the key (no key_fn needed)\nraster_stack = RasterStack(\n    tasks=tasks,\n    timestamp_fn=lambda asset: asset[\"datetime\"],  # Returns datetime, used as key\n)\n</code></pre>"},{"location":"migration-rasterstack/#3-replace-to_raster_stack-with-factory-methods","title":"3. Replace to_raster_stack() with Factory Methods","text":"<pre><code># Before\nfrom titiler.openeo.processes.implementations.data_model import to_raster_stack\n\nimg_data = ImageData(...)\nraster_stack = to_raster_stack(img_data)  # {\"data\": img_data}\n\n# After - use datetime keys\nfrom datetime import datetime\nraster_stack = RasterStack.from_images({datetime.now(): img_data})\n</code></pre>"},{"location":"migration-rasterstack/#4-replace-get_first_item-get_last_item","title":"4. Replace get_first_item() / get_last_item()","text":"<pre><code># Before\nfrom titiler.openeo.processes.implementations.data_model import get_first_item, get_last_item\n\nfirst = get_first_item(raster_stack)\nlast = get_last_item(raster_stack)\n\n# After (using properties)\nfirst = raster_stack.first\nlast = raster_stack.last\n\n# Alternative for plain dicts in tests\nfirst = next(iter(my_dict.values()))\n</code></pre>"},{"location":"migration-rasterstack/#5-replace-lazyimageref-with-imageref","title":"5. Replace LazyImageRef with ImageRef","text":"<p>The unified <code>ImageRef</code> class handles both lazy and eager states. Note that the <code>key</code> field is no longer used - the key is managed by the containing <code>RasterStack</code>:</p> <pre><code># Before (lazy)\nref = LazyImageRef(\n    key=\"my_key\",\n    task_fn=lambda: load_image(),\n    width=256,\n    height=256,\n    ...\n)\n\n# After (lazy) - no key parameter\nref = ImageRef.from_task(\n    task_fn=lambda: load_image(),\n    width=256,\n    height=256,\n    ...\n)\n\n# After (eager - pre-loaded image) - no key parameter\nref = ImageRef.from_image(image=my_image_data)\n</code></pre>"},{"location":"migration-rasterstack/#6-update-isinstance-checks","title":"6. Update isinstance Checks","text":"<pre><code># Before\nif isinstance(data, LazyRasterStack):\n    ...\nelif isinstance(data, dict):\n    ...\n\n# After (single type)\nif isinstance(data, RasterStack):\n    ...\n</code></pre>"},{"location":"migration-rasterstack/#imageref-state-management","title":"ImageRef State Management","text":"<p>The new <code>ImageRef</code> class manages lazy/eager state internally:</p> <pre><code>ref = ImageRef.from_task(task_fn=load_fn, ...)\n\n# Check if data is loaded\nif ref.realized:\n    print(\"Data already loaded\")\nelse:\n    print(\"Data will load on first access\")\n\n# Access data (loads if necessary)\nimage = ref.realize()\n\n# After realize(), ref.realized is True\nassert ref.realized\n</code></pre>"},{"location":"migration-rasterstack/#new-factory-methods","title":"New Factory Methods","text":""},{"location":"migration-rasterstack/#rasterstackfrom_images","title":"RasterStack.from_images()","text":"<p>Create a RasterStack from pre-loaded ImageData (uses datetime keys):</p> <pre><code>from datetime import datetime\n\nimages = {\n    datetime(2023, 1, 1): ImageData(...),\n    datetime(2023, 1, 15): ImageData(...),\n}\nraster_stack = RasterStack.from_images(images)\n</code></pre>"},{"location":"migration-rasterstack/#rasterstackfrom_tasks","title":"RasterStack.from_tasks()","text":"<p>Create a RasterStack from task tuples (same as constructor). The datetime returned by <code>timestamp_fn</code> is used directly as the key:</p> <pre><code>tasks = [\n    (load_fn1, {\"id\": \"item1\", \"datetime\": dt1}),\n    (load_fn2, {\"id\": \"item2\", \"datetime\": dt2}),\n]\n# timestamp_fn returns datetime, which IS used as the key (no key_fn)\nraster_stack = RasterStack.from_tasks(\n    tasks=tasks,\n    timestamp_fn=lambda a: a[\"datetime\"],\n)\n</code></pre>"},{"location":"migration-rasterstack/#imagereffrom_task","title":"ImageRef.from_task()","text":"<p>Create a lazy ImageRef (no <code>key</code> parameter - key is managed by RasterStack):</p> <pre><code>ref = ImageRef.from_task(\n    task_fn=lambda: load_image(),\n    width=256,\n    height=256,\n    bounds=(0, 0, 1, 1),\n    crs=CRS.from_epsg(4326),\n    band_names=[\"red\", \"green\", \"blue\"],\n    geometry={\"type\": \"Polygon\", ...},  # Optional, for cutline mask\n)\n</code></pre>"},{"location":"migration-rasterstack/#imagereffrom_image","title":"ImageRef.from_image()","text":"<p>Create an eager ImageRef from pre-loaded data (no <code>key</code> parameter):</p> <pre><code>ref = ImageRef.from_image(image=my_image_data)\n</code></pre>"},{"location":"migration-rasterstack/#benefits-of-the-new-architecture","title":"Benefits of the New Architecture","text":"<ol> <li>Simpler mental model: One class (<code>RasterStack</code>) instead of two</li> <li>No isinstance checks: All code paths work with <code>RasterStack</code></li> <li>Unified ImageRef: Single class manages lazy/eager state internally</li> <li>Better factory methods: Clear entry points for different use cases</li> <li>Cleaner code: No <code>Union</code> types or multiple collection patterns</li> </ol>"},{"location":"migration-rasterstack/#common-patterns","title":"Common Patterns","text":""},{"location":"migration-rasterstack/#processing-all-images","title":"Processing All Images","text":"<pre><code># Get all image references (lazy) - keys are datetime objects\nfor dt_key, ref in raster_stack.get_image_refs():\n    # Compute cutline mask WITHOUT loading data\n    mask = ref.cutline_mask()\n\n    # Load data only when needed\n    image = ref.realize()\n</code></pre>"},{"location":"migration-rasterstack/#temporal-access","title":"Temporal Access","text":"<pre><code># Get sorted timestamps (keys ARE timestamps)\nfor timestamp in raster_stack.timestamps():\n    print(f\"Available: {timestamp}\")\n\n# Keys are datetime objects, already in temporal order\nfor dt_key in raster_stack.keys():\n    print(f\"Observation at: {dt_key}\")\n\n# Efficient first/last access\nfirst_image = raster_stack.first\nlast_image = raster_stack.last\n</code></pre>"},{"location":"migration-rasterstack/#testing-with-pre-loaded-images","title":"Testing with Pre-loaded Images","text":"<pre><code># For tests, use from_images() with datetime keys\nfrom datetime import datetime\n\ndef test_my_process():\n    dt1, dt2 = datetime(2023, 1, 1), datetime(2023, 1, 15)\n    images = {dt1: create_test_image(), dt2: create_test_image()}\n    raster_stack = RasterStack.from_images(images)\n\n    result = my_process(raster_stack)\n    assert result.first.array.shape == expected_shape\n</code></pre>"},{"location":"openid-connect/","title":"OpenID Connect Configuration","text":"<p>TiTiler-OpenEO supports OpenID Connect (OIDC) authentication following the OpenEO authentication model. The implementation supports the OpenID Connect Authorization Code Flow with PKCE.</p> <p>The implementation is available in <code>titiler/openeo/auth.py</code> with the main class being <code>OIDCAuth</code>.</p>"},{"location":"openid-connect/#openeo-authentication-model","title":"OpenEO Authentication Model","text":"<p>TiTiler-OpenEO follows the OpenEO authentication specification where tokens are provided in the format:</p> <pre><code>Bearer oidc/oidc/{actual_token}\n</code></pre> <p>The token structure consists of three parts:</p> <ol> <li>Authentication method (<code>oidc</code>)</li> <li>Provider identifier (<code>oidc</code>)</li> <li>The actual OIDC token</li> </ol> <p>Token parsing is handled by the <code>AuthToken</code> class.</p>"},{"location":"openid-connect/#configuration","title":"Configuration","text":"<p>The OIDC configuration is managed through <code>OIDCConfig</code> in the settings. To enable OpenID Connect authentication, configure the following environment variables:</p> <pre><code>TITILER_OPENEO_AUTH_METHOD=oidc\nTITILER_OPENEO_AUTH_OIDC_CLIENT_ID=\"your-client-id\"\nTITILER_OPENEO_AUTH_OIDC_WK_URL=\"https://your-provider/.well-known/openid-configuration\"\nTITILER_OPENEO_AUTH_OIDC_REDIRECT_URL=\"your-redirect-url\"\n</code></pre> <p>Optional configuration:</p> <pre><code>TITILER_OPENEO_AUTH_OIDC_SCOPES=\"openid email profile\"  # Space-separated list (default)\nTITILER_OPENEO_AUTH_OIDC_NAME_CLAIM=\"name\"  # Claim to use for user name (default)\nTITILER_OPENEO_AUTH_OIDC_TITLE=\"OIDC\"  # Provider title (default)\nTITILER_OPENEO_AUTH_OIDC_DESCRIPTION=\"OpenID Connect (OIDC) Authorization Code Flow with PKCE\"  # Provider description (default)\n</code></pre>"},{"location":"openid-connect/#token-validation","title":"Token Validation","text":"<p>The OIDC implementation performs the following validations in the <code>_verify_token</code> method:</p> <ol> <li>Verifies the token signature using the provider's JWKS</li> <li>Validates token claims including:</li> <li>Client ID matches the configured one</li> <li>Token expiration</li> <li>Token audience</li> </ol>"},{"location":"openid-connect/#user-information","title":"User Information","text":"<p>Upon successful validation, a <code>User</code> object is created with:</p> <ul> <li><code>user_id</code>: Subject claim from the token (<code>sub</code>)</li> <li><code>email</code>: Email claim if available</li> <li><code>name</code>: Value from the configured name claim (defaults to \"name\")</li> </ul>"},{"location":"openid-connect/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keep your client ID secure</li> <li>Configure appropriate token expiration times</li> <li>Use HTTPS in production</li> <li>Review and limit the requested scopes</li> <li>Regularly rotate any client secrets if used</li> </ul> <p>For more details on the implementation, see the auth module source code.</p>"},{"location":"parameter-management/","title":"Parameter Management","text":"<p>This document explains the comprehensive parameter management system in openEO by TiTiler, which provides dynamic parameter substitution for both synchronous result processing and XYZ tile services.</p>"},{"location":"parameter-management/#overview","title":"Overview","text":"<p>The parameter management system allows you to create flexible, reusable process graphs that can accept dynamic parameters at runtime. This enables:</p> <ul> <li>Dynamic Query Parameters: Pass parameters via query strings in API requests</li> <li>Default Parameter Values: Define fallback values in process graph definitions</li> <li>Automatic Parameter Injection: Built-in injection of system parameters like user information</li> <li>Parameter Precedence: Clear hierarchy for parameter resolution</li> </ul>"},{"location":"parameter-management/#parameter-types","title":"Parameter Types","text":""},{"location":"parameter-management/#1-process-graph-parameters","title":"1. Process Graph Parameters","text":"<p>Parameters defined in the process graph definition with optional default values:</p> <pre><code>{\n  \"process_graph\": {\n    \"load1\": {\n      \"process_id\": \"load_collection\",\n      \"arguments\": {\n        \"id\": \"S2\",\n        \"spatial_extent\": { \"from_parameter\": \"bbox\" },\n        \"temporal_extent\": { \"from_parameter\": \"time_range\" }\n      },\n      \"result\": true\n    }\n  },\n  \"parameters\": [\n    {\n      \"name\": \"bbox\",\n      \"description\": \"Spatial bounding box\",\n      \"schema\": { \"type\": \"object\" },\n      \"default\": {\n        \"west\": 16.1,\n        \"east\": 16.6,\n        \"north\": 48.6,\n        \"south\": 47.2\n      }\n    },\n    {\n      \"name\": \"time_range\",\n      \"description\": \"Temporal extent\",\n      \"schema\": { \"type\": \"array\" },\n      \"default\": [\"2023-01-01\", \"2023-12-31\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"parameter-management/#2-query-parameters","title":"2. Query Parameters","text":"<p>Parameters passed in the URL query string that override defaults:</p> <pre><code># Override bbox parameter\nGET /result?bbox={\"west\":10.0,\"east\":20.0,\"north\":50.0,\"south\":40.0}\n\n# Override multiple parameters\nGET /services/xyz/{service_id}/tiles/{z}/{x}/{y}?time_range=[\"2024-01-01\",\"2024-06-30\"]&amp;bands=[\"red\",\"green\",\"blue\"]\n</code></pre>"},{"location":"parameter-management/#3-reserved-system-parameters","title":"3. Reserved System Parameters","text":"<p>Automatically injected parameters that provide system context:</p> Parameter Description Available In Comment <code>_openeo_user</code> Authenticated user object Both endpoints <code>_openeo_tile_store</code> Tile storage backend XYZ services only <code>spatial_extent_*</code> Tile boundary coordinates XYZ services only Deprecated. Will be removed in a future release. Use <code>bounding_box</code> instead. <code>tile_x</code>, <code>tile_y</code>, <code>tile_z</code> Tile coordinates XYZ services only <code>bounding_box</code> Tile bounding box object XYZ services only"},{"location":"parameter-management/#parameter-resolution-priority","title":"Parameter Resolution Priority","text":"<p>Parameters are resolved in the following order (highest to lowest priority):</p> <ol> <li>Query Parameters: Values passed in the URL query string</li> <li>System Parameters: Automatically injected reserved parameters</li> <li>Default Values: Default values defined in the process graph parameters</li> <li>Process Defaults: Built-in default values from process implementations</li> </ol>"},{"location":"parameter-management/#endpoint-support","title":"Endpoint Support","text":""},{"location":"parameter-management/#post-result-synchronous-processing","title":"POST /result (Synchronous Processing)","text":"<p>The <code>/result</code> endpoint supports full parameter management:</p> <pre><code>POST /result?temporal_extent=[\"2024-01-01\",\"2024-12-31\"]&amp;bands=[\"B04\",\"B08\"]\nContent-Type: application/json\n\n{\n  \"process\": {\n    \"process_graph\": {\n      \"load1\": {\n        \"process_id\": \"load_collection\",\n        \"arguments\": {\n          \"id\": \"S2\",\n          \"temporal_extent\": {\"from_parameter\": \"temporal_extent\"},\n          \"bands\": {\"from_parameter\": \"bands\"}\n        },\n        \"result\": true\n      }\n    },\n    \"parameters\": [\n      {\n        \"name\": \"temporal_extent\",\n        \"schema\": {\"type\": \"array\"},\n        \"default\": [\"2023-01-01\", \"2023-12-31\"]\n      },\n      {\n        \"name\": \"bands\",\n        \"schema\": {\"type\": \"array\"},\n        \"default\": [\"B04\", \"B03\", \"B02\"]\n      }\n    ]\n  }\n}\n</code></pre> <p>Features:</p> <ul> <li>Query parameter parsing and JSON deserialization</li> <li>User injection via <code>_openeo_user</code> parameter</li> <li>Default parameter value application</li> <li>Built-in parameter substitution via OpenEO process graph parser</li> </ul>"},{"location":"parameter-management/#get-servicesxyzservice_idtileszxy-xyz-tile-service","title":"GET /services/xyz/{service_id}/tiles/{z}/{x}/{y} (XYZ Tile Service)","text":"<p>XYZ tile services support the same parameter management with additional spatial context:</p> <pre><code>GET /services/xyz/abc123/tiles/10/512/341?temporal_extent=[\"2024-06-01\",\"2024-06-30\"]\n</code></pre> <p>Additional Features:</p> <ul> <li>Automatic spatial parameter injection (tile bounds, coordinates)</li> <li>Tile-specific context parameters</li> <li>Same query parameter and default value support as <code>/result</code></li> </ul>"},{"location":"parameter-management/#parameter-validation","title":"Parameter Validation","text":""},{"location":"parameter-management/#json-parameter-validation","title":"JSON Parameter Validation","text":"<p>Complex parameters passed as query strings are automatically parsed as JSON:</p> <pre><code># Array parameter\n?bands=[\"red\",\"green\",\"blue\"]\n\n# Object parameter\n?bounding_box={\"west\":10,\"east\":20,\"north\":50,\"south\":40}\n\n# Nested object parameter\n?filter_options={\"cloud_cover\":{\"max\":20},\"processing_level\":\"L2A\"}\n</code></pre>"},{"location":"parameter-management/#schema-validation","title":"Schema Validation","text":"<p>Parameters are validated against their schema definitions:</p> <pre><code>{\n  \"name\": \"cloud_cover_max\",\n  \"description\": \"Maximum cloud cover percentage\",\n  \"schema\": {\n    \"type\": \"number\",\n    \"minimum\": 0,\n    \"maximum\": 100\n  },\n  \"default\": 20\n}\n</code></pre>"},{"location":"parameter-management/#best-practices","title":"Best Practices","text":""},{"location":"parameter-management/#1-parameter-naming","title":"1. Parameter Naming","text":"<ul> <li>Use descriptive, lowercase parameter names</li> <li>Use underscores for multi-word parameters: <code>temporal_extent</code>, <code>cloud_cover_max</code></li> <li>Avoid conflicts with reserved parameter names (<code>_openeo_*</code>)</li> </ul>"},{"location":"parameter-management/#2-default-values","title":"2. Default Values","text":"<ul> <li>Always provide sensible default values for optional parameters</li> <li>Ensure defaults work across your expected data collections and time ranges</li> <li>Document the reasoning behind default choices</li> </ul>"},{"location":"parameter-management/#3-parameter-documentation","title":"3. Parameter Documentation","text":"<pre><code>{\n  \"name\": \"temporal_extent\",\n  \"description\": \"Temporal extent as [start_date, end_date] in ISO 8601 format\",\n  \"schema\": {\n    \"type\": \"array\",\n    \"minItems\": 2,\n    \"maxItems\": 2,\n    \"items\": { \"type\": \"string\", \"format\": \"date\" }\n  },\n  \"default\": [\"2023-01-01\", \"2023-12-31\"],\n  \"examples\": [\n    [\"2024-01-01\", \"2024-06-30\"],\n    [\"2023-07-15\", \"2023-08-15\"]\n  ]\n}\n</code></pre>"},{"location":"parameter-management/#4-complex-parameters","title":"4. Complex Parameters","text":"<p>For complex nested parameters, use clear structure and validation:</p> <pre><code>{\n  \"name\": \"processing_options\",\n  \"description\": \"Processing configuration options\",\n  \"schema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"cloud_mask\": { \"type\": \"boolean\", \"default\": true },\n      \"atmospheric_correction\": { \"type\": \"boolean\", \"default\": false },\n      \"resampling\": {\n        \"type\": \"string\",\n        \"enum\": [\"nearest\", \"bilinear\", \"cubic\"],\n        \"default\": \"bilinear\"\n      }\n    }\n  },\n  \"default\": {\n    \"cloud_mask\": true,\n    \"atmospheric_correction\": false,\n    \"resampling\": \"bilinear\"\n  }\n}\n</code></pre>"},{"location":"parameter-management/#examples","title":"Examples","text":""},{"location":"parameter-management/#basic-parameter-usage","title":"Basic Parameter Usage","text":"<p>Simple parameter substitution with defaults:</p> <pre><code>{\n  \"process_graph\": {\n    \"load1\": {\n      \"process_id\": \"load_collection\",\n      \"arguments\": {\n        \"id\": { \"from_parameter\": \"collection\" },\n        \"temporal_extent\": { \"from_parameter\": \"time_range\" }\n      },\n      \"result\": true\n    }\n  },\n  \"parameters\": [\n    {\n      \"name\": \"collection\",\n      \"schema\": { \"type\": \"string\" },\n      \"default\": \"S2\"\n    },\n    {\n      \"name\": \"time_range\",\n      \"schema\": { \"type\": \"array\" },\n      \"default\": [\"2023-01-01\", \"2023-12-31\"]\n    }\n  ]\n}\n</code></pre> <p>Usage: <code>POST /result?collection=L8&amp;time_range=[\"2024-01-01\",\"2024-06-30\"]</code></p>"},{"location":"parameter-management/#advanced-parameter-usage","title":"Advanced Parameter Usage","text":"<p>Complex parameters with validation and user context:</p> <pre><code>{\n  \"process_graph\": {\n    \"load1\": {\n      \"process_id\": \"load_collection\",\n      \"arguments\": {\n        \"id\": \"S2\",\n        \"spatial_extent\": { \"from_parameter\": \"bbox\" },\n        \"temporal_extent\": { \"from_parameter\": \"time_range\" }\n      }\n    },\n    \"filter1\": {\n      \"process_id\": \"filter_bands\",\n      \"arguments\": {\n        \"data\": { \"from_node\": \"load1\" },\n        \"bands\": { \"from_parameter\": \"bands\" }\n      }\n    },\n    \"user_process\": {\n      \"process_id\": \"custom_user_process\",\n      \"arguments\": {\n        \"data\": { \"from_node\": \"filter1\" },\n        \"user_id\": { \"from_parameter\": \"_openeo_user\" }\n      },\n      \"result\": true\n    }\n  },\n  \"parameters\": [\n    {\n      \"name\": \"bbox\",\n      \"description\": \"Spatial bounding box\",\n      \"schema\": {\n        \"type\": \"object\",\n        \"required\": [\"west\", \"east\", \"north\", \"south\"],\n        \"properties\": {\n          \"west\": { \"type\": \"number\" },\n          \"east\": { \"type\": \"number\" },\n          \"north\": { \"type\": \"number\" },\n          \"south\": { \"type\": \"number\" }\n        }\n      }\n    },\n    {\n      \"name\": \"time_range\",\n      \"schema\": { \"type\": \"array\" },\n      \"default\": [\"2023-01-01\", \"2023-12-31\"]\n    },\n    {\n      \"name\": \"bands\",\n      \"schema\": { \"type\": \"array\" },\n      \"default\": [\"B04\", \"B03\", \"B02\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"parameter-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"parameter-management/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Parameter Not Found: Ensure parameter names match exactly between <code>from_parameter</code> references and parameter definitions.</p> </li> <li> <p>Invalid JSON in Query: When passing complex parameters, ensure proper URL encoding:</p> </li> </ol> <pre><code># Correct\n?bbox=%7B%22west%22%3A10%2C%22east%22%3A20%7D\n\n# Also correct (many tools handle this automatically)\n?bbox={\"west\":10,\"east\":20}\n</code></pre> <ol> <li>Type Validation Errors: Ensure parameter values match their schema types:</li> </ol> <pre><code># Wrong - string instead of number\n?cloud_cover=\"20\"\n\n# Correct\n?cloud_cover=20\n</code></pre> <ol> <li>Reserved Parameter Conflicts: Don't define parameters that conflict with reserved names (<code>_openeo_*</code>, <code>spatial_extent_*</code>, <code>tile_*</code>).</li> </ol>"},{"location":"parameter-management/#debugging","title":"Debugging","text":"<p>Enable debug logging to see parameter resolution:</p> <pre><code>import logging\nlogging.getLogger('titiler.openeo.factory').setLevel(logging.DEBUG)\n</code></pre> <p>This will show:</p> <ul> <li>Query parameter parsing results</li> <li>Default parameter application</li> <li>Final parameter values passed to process graph</li> </ul>"},{"location":"project-overview/","title":"Project Overview","text":""},{"location":"project-overview/#about-openeo-by-titiler","title":"About openEO by TiTiler","text":"<p>openEO by TiTiler is a fast and lightweight implementation of the openEO API, developed by Development Seed. It provides efficient management of raster-based processes using the TiTiler engine.</p>"},{"location":"project-overview/#context","title":"Context","text":"<p>openEO serves as an abstraction layer for Earth Observation (EO) processing and has gained significant traction within the community. Several data hubs now offer openEO as a service, notably the Copernicus Data Space Ecosystem, Terrascope, and EODC. Additionally, EOEPCA+, with its processing building block, is furthering the deployment of openEO.</p>"},{"location":"project-overview/#features","title":"Features","text":"<p>The main features include:</p> <ul> <li>Built on top of FastAPI</li> <li>Cloud Optimized GeoTIFF support</li> <li>SpatioTemporal Asset Catalog support</li> <li>Multiple projections support via morecantile</li> <li>JPEG / PNG / Geotiff / JSON / CSV output format support</li> <li>XYZ secondary service support</li> <li>Automatic OpenAPI documentation</li> <li>Parameter management with dynamic query parameters, defaults, and validation</li> <li>Unified parameter handling across synchronous processing and XYZ tile services</li> </ul>"},{"location":"project-overview/#api-support","title":"API Support","text":"<p>The application implements the openEO API (L1A and L1C) profiles:</p> <ul> <li>Synchronous Processing (L1A): For direct processing and downloading of data</li> <li>Secondary Web Services (L1C): For data visualization with dynamic tiling</li> </ul>"},{"location":"project-overview/#project-goals","title":"Project Goals","text":"<p>The primary objectives of this project are:</p> <ol> <li>Provide a lightweight and fast backend for openEO services</li> <li>Focus on efficient raster data processing</li> <li>Enable dynamic tiling and visualization capabilities</li> <li>Maintain compatibility with STAC API services</li> <li>Deliver high-performance synchronous processing</li> </ol>"},{"location":"raster-stack/","title":"RasterStack Data Model","text":"<p>In titiler-openeo, the <code>RasterStack</code> class is the foundational data structure for handling Earth Observation datasets. This document explains the RasterStack architecture, its lazy loading capabilities, and the performance benefits it provides.</p>"},{"location":"raster-stack/#overview","title":"Overview","text":"<p><code>RasterStack</code> is a class that organizes raster data along multiple dimensions, primarily time and spectral bands. Each entry contains an <code>ImageData</code> object representing a multi-band image at a specific time point. The class inherits from <code>Dict[datetime, ImageData]</code> but adds lazy loading, temporal awareness, and intelligent caching.</p> <p>Key architectural principle: When <code>load_collection</code> creates a RasterStack, it groups items by timestamp and merges overlapping tiles using <code>mosaic_reader</code>. This guarantees one entry per timestamp - all spatial tiles from the same acquisition are already mosaicked together.</p> <pre><code>from titiler.openeo.processes.implementations.data_model import RasterStack\nfrom datetime import datetime\n\n# RasterStack behaves like a dict but with lazy loading\n# Keys are datetime objects directly - no separate key_fn needed\nraster_stack = RasterStack(\n    tasks=tasks,\n    timestamp_fn=lambda asset: asset[\"datetime\"],  # Returns datetime, used as key\n)\n\n# Access by datetime key triggers lazy loading\ndt = datetime(2023, 1, 1)\nfirst_image = raster_stack[dt]  # Loads data on first access\n</code></pre>"},{"location":"raster-stack/#dimensional-model","title":"Dimensional Model","text":"<p>The RasterStack defines a clear dimensional hierarchy:</p> <ol> <li>Time Dimension (Primary): RasterStack keys represent temporal organization</li> <li>Spectral Dimension (Secondary): Each ImageData contains multiple bands</li> <li>Spatial Dimensions: Each band contains 2D spatial data (height, width)</li> </ol> <pre><code># Time dimension: multiple temporal observations (datetime keys)\nfrom datetime import datetime\n\ntemporal_stack = {\n    datetime(2023, 1, 1): ImageData(array.shape=(4, 512, 512)),  # 4 bands\n    datetime(2023, 2, 1): ImageData(array.shape=(4, 512, 512)),  # 4 bands\n}\n\n# Each ImageData represents multi-band observations at one time point\nsingle_observation = temporal_stack[datetime(2023, 1, 1)]\n# single_observation.array.shape = (bands, height, width) = (4, 512, 512)\n</code></pre>"},{"location":"raster-stack/#imagedata-vs-rasterstack","title":"ImageData vs RasterStack","text":"<ul> <li>ImageData: Multi-band raster data for a single time point with spatial extent, CRS, and band metadata</li> <li>RasterStack: Time-organized collection of ImageData objects with lazy loading, enabling temporal analysis and processing</li> </ul>"},{"location":"raster-stack/#rasterstack-with-temporal-intelligence","title":"RasterStack with Temporal Intelligence","text":"<p><code>RasterStack</code> provides sophisticated time-aware lazy loading and concurrent execution capabilities:</p> <pre><code>from titiler.openeo.processes.implementations.data_model import RasterStack\n\n# RasterStack with datetime keys (timestamp IS the key)\nraster_stack = RasterStack(\n    tasks=tasks,\n    timestamp_fn=lambda asset: asset[\"datetime\"],  # Returns datetime, used as key\n    max_workers=5  # Concurrent execution\n)\n\n# Temporal access - keys ARE timestamps (datetime objects)\nall_timestamps = raster_stack.timestamps()  # Sorted list of datetime keys\nfirst_timestamp = next(iter(raster_stack.keys()))  # First datetime key\n</code></pre>"},{"location":"raster-stack/#key-features-of-rasterstack","title":"Key Features of RasterStack","text":"<ol> <li>Temporal Organization: Automatic sorting by timestamps for time-series analysis (one item per timestamp)</li> <li>Concurrent Execution: Parallel loading of data using ThreadPoolExecutor for improved performance</li> <li>Datetime Keys: Keys are <code>datetime</code> objects directly - no separate key/timestamp mapping needed</li> <li>Intelligent Caching: Per-key caching to avoid redundant computations</li> <li>Lazy Evaluation: Data loaded only when accessed, reducing memory footprint</li> <li>Multi-band Support: Each temporal observation can contain multiple spectral bands</li> </ol>"},{"location":"raster-stack/#temporal-processing-capabilities","title":"Temporal Processing Capabilities","text":"<pre><code># Get sorted list of all timestamps (keys ARE timestamps)\nfor timestamp in raster_stack.timestamps():\n    print(f\"Available observation at: {timestamp}\")\n\n# Process data chronologically - keys are datetime objects\nfor dt_key in raster_stack.keys():  # Already in temporal order\n    item = raster_stack[dt_key]\n    print(f\"Processing observation from {dt_key}\")\n\n# Efficient time-series operations via first/last properties\nfirst_observation = raster_stack.first  # Earliest observation\nlast_observation = raster_stack.last    # Latest observation\n</code></pre>"},{"location":"raster-stack/#advantages-of-the-rasterstack-model","title":"Advantages of the RasterStack Model","text":"<ul> <li>Temporal Consistency: Standardized time-first organization for all Earth Observation workflows</li> <li>Multi-dimensional Support: Explicit handling of time and spectral dimensions</li> <li>Concurrent Performance: Parallel data loading reduces processing time for large datasets</li> <li>Memory Efficiency: RasterStack with intelligent caching minimizes memory usage</li> <li>Scalability: Efficient handling of time-series data with hundreds of temporal observations</li> <li>Predictability: Standardized multi-dimensional structure across all operations</li> </ul>"},{"location":"raster-stack/#dimensional-processing-patterns","title":"Dimensional Processing Patterns","text":""},{"location":"raster-stack/#temporal-dimension-operations","title":"Temporal Dimension Operations","text":"<pre><code># Reduce across time (e.g., temporal mean)\nfrom titiler.openeo.processes.implementations.reduce import reduce_dimension\n\ntemporal_mean = reduce_dimension(\n    data=raster_stack,\n    reducer=mean_reducer,\n    dimension=\"temporal\"\n)\n# Result: Single ImageData with time-averaged bands\n</code></pre>"},{"location":"raster-stack/#spectral-dimension-operations","title":"Spectral Dimension Operations","text":"<pre><code># Reduce across bands (e.g., NDVI calculation)\nndvi_stack = reduce_dimension(\n    data=raster_stack, \n    reducer=ndvi_calculator,\n    dimension=\"spectral\"\n)\n# Result: RasterStack with single-band NDVI for each time point\n</code></pre>"},{"location":"raster-stack/#combined-processing","title":"Combined Processing","text":"<pre><code># Apply pixel selection across temporal groups\nfrom titiler.openeo.processes.implementations.reduce import apply_pixel_selection\n\n# Mosaic overlapping observations at each time point\nmosaicked_stack = apply_pixel_selection(\n    data=raster_stack,\n    pixel_selection=\"first\"  # Uses temporal grouping automatically\n)\n</code></pre>"},{"location":"raster-stack/#how-multi-dimensional-processing-works","title":"How Multi-dimensional Processing Works","text":""},{"location":"raster-stack/#load-phase-temporal-organization-with-per-timestamp-mosaic","title":"Load Phase - Temporal Organization with Per-Timestamp Mosaic","text":"<p>When <code>load_collection</code> retrieves satellite imagery, it automatically groups STAC items by their acquisition timestamp and merges overlapping tiles using <code>mosaic_reader</code>. This means:</p> <ul> <li>One entry per timestamp: Each timestamp in the RasterStack contains a single merged <code>ImageData</code>, even if multiple tiles cover the area</li> <li>Automatic tile merging: Overlapping tiles from the same acquisition are mosaicked together</li> <li>No duplicate timestamps: The RasterStack is guaranteed to have unique timestamps</li> </ul> <pre><code># Process graph example - loads multi-band time series\n{\n  \"process_id\": \"load_collection\",\n  \"arguments\": {\n    \"id\": \"sentinel-2-l2a\",\n    \"spatial_extent\": {...},\n    \"temporal_extent\": [\"2023-01-01\", \"2023-03-01\"],\n    \"bands\": [\"B02\", \"B03\", \"B04\", \"B08\"]  # Blue, Green, Red, NIR\n  }\n}\n# Results in RasterStack with one entry per acquisition date\n# Multiple tiles from the same date are mosaicked into a single ImageData\n</code></pre> <p>This design simplifies temporal processing since each key represents a unique moment in time with all spatial tiles already merged.</p>"},{"location":"raster-stack/#process-phase-dimension-aware-operations","title":"Process Phase - Dimension-aware Operations","text":"<p>Operations are applied respecting dimensional structure:</p> <pre><code># Spectral processing within each time point\n{\n  \"process_id\": \"normalized_difference\", \n  \"arguments\": {\n    \"x\": {\"from_node\": \"load_collection\", \"band\": \"B08\"},  # NIR\n    \"y\": {\"from_node\": \"load_collection\", \"band\": \"B04\"}   # Red\n  }\n}\n# Produces single-band NDVI for each temporal observation\n</code></pre>"},{"location":"raster-stack/#temporal-analysis","title":"Temporal Analysis","text":"<pre><code># Time-series analysis across the temporal dimension\n{\n  \"process_id\": \"reduce_dimension\",\n  \"arguments\": {\n    \"data\": {\"from_node\": \"ndvi_calculation\"},\n    \"reducer\": {\"process_id\": \"mean\"},\n    \"dimension\": \"temporal\"\n  }\n}\n# Produces temporal mean NDVI (collapses time dimension)\n</code></pre>"},{"location":"raster-stack/#code-examples","title":"Code Examples","text":""},{"location":"raster-stack/#working-with-temporal-rasterstacks","title":"Working with Temporal RasterStacks","text":"<pre><code># Create a time-aware RasterStack\nfrom titiler.openeo.processes.implementations.data_model import RasterStack\nfrom datetime import datetime\n\n# Tasks with temporal metadata\ntasks = [\n    (load_task, {\"id\": \"s2_20230101\", \"datetime\": datetime(2023, 1, 1)}),\n    (load_task, {\"id\": \"s2_20230115\", \"datetime\": datetime(2023, 1, 15)}),\n]\n\n# timestamp_fn returns datetime, which IS used as the key\nraster_stack = RasterStack(\n    tasks=tasks,\n    timestamp_fn=lambda asset: asset[\"datetime\"]\n)\n\n# Access by datetime key (keys are ordered by timestamp)\nfirst_item = raster_stack.first  # First observation\nlast_item = raster_stack.last    # Last observation\n\n# Temporal iteration (keys are datetime objects, already in temporal order)\nfor dt_key in raster_stack.keys():\n    print(f\"Time {dt_key}\")\n</code></pre>"},{"location":"raster-stack/#multi-band-processing","title":"Multi-band Processing","text":"<pre><code># Access spectral bands within temporal observations\ndt = datetime(2023, 1, 1)\nobservation = raster_stack[dt]  # Multi-band ImageData\nbands = observation.band_names  # [\"B02\", \"B03\", \"B04\", \"B08\"]\nnir_band = observation.array[3]  # NIR band (B08)\nred_band = observation.array[2]  # Red band (B04)\n\n# Calculate NDVI for this time point\nndvi = (nir_band - red_band) / (nir_band + red_band)\n</code></pre>"},{"location":"raster-stack/#factory-methods","title":"Factory Methods","text":"<pre><code>from titiler.openeo.processes.implementations.data_model import RasterStack\nfrom datetime import datetime\n\n# Create RasterStack from pre-loaded images (datetime keys)\nimages = {\n    datetime(2023, 1, 1): ImageData(...),\n    datetime(2023, 1, 15): ImageData(...),\n}\nraster_stack = RasterStack.from_images(images)\n\n# Access first and last images\nfirst_observation = raster_stack.first  # Earliest in time\nlast_observation = raster_stack.last    # Latest in time\n</code></pre>"},{"location":"raster-stack/#performance-benefits","title":"Performance Benefits","text":"<p>The <code>RasterStack</code> implementation provides significant performance improvements:</p>"},{"location":"raster-stack/#concurrent-execution","title":"Concurrent Execution","text":"<ul> <li>Parallel Loading: ThreadPoolExecutor enables concurrent data loading within timestamp groups</li> <li>Configurable Workers: Adjustable <code>max_workers</code> parameter for optimal resource utilization</li> <li>Timestamp Grouping: Efficient parallel processing of observations at the same time point</li> </ul>"},{"location":"raster-stack/#memory-optimization","title":"Memory Optimization","text":"<ul> <li>Lazy Evaluation: Only loads data when explicitly accessed or processed</li> <li>Per-key Caching: Intelligent caching prevents redundant task execution</li> <li>Selective Loading: Timestamp-based access loads only relevant temporal subsets</li> </ul>"},{"location":"raster-stack/#computational-efficiency","title":"Computational Efficiency","text":"<ul> <li>Early Termination: Pixel selection and reduction operations can stop early when sufficient data is found</li> <li>Temporal Ordering: Pre-sorted temporal access eliminates runtime sorting overhead</li> <li>Exception Resilience: Graceful handling of failed tasks without blocking entire workflows</li> </ul>"},{"location":"raster-stack/#scalability-improvements","title":"Scalability Improvements","text":"<ol> <li>Large Time Series: Efficiently handles datasets with hundreds of temporal observations</li> <li>Multi-band Support: Optimized processing of high-dimensional spectral data</li> <li>Memory Footprint: Reduced memory usage for large Earth Observation collections</li> <li>Processing Speed: Concurrent execution significantly reduces wall-clock time</li> </ol>"},{"location":"raster-stack/#best-practices","title":"Best Practices","text":"<p>When working with the RasterStack data model:</p>"},{"location":"raster-stack/#temporal-organization","title":"Temporal Organization","text":"<ol> <li>Use timestamp functions: Always provide <code>timestamp_fn</code> for time-series data - the returned datetime IS the key</li> <li>Leverage temporal ordering: Keys (datetime objects) are automatically sorted for chronological processing</li> <li>Use first/last properties: Access <code>.first</code> and <code>.last</code> for efficient endpoint access</li> </ol>"},{"location":"raster-stack/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Configure concurrency: Adjust <code>max_workers</code> based on your system resources and data characteristics</li> <li>Use dimension reduction: Apply <code>reduce_dimension()</code> to collapse unnecessary dimensions early in processing</li> <li>Employ early termination: Use pixel selection methods that can terminate early (\"first\", \"mean\") when possible</li> </ol>"},{"location":"raster-stack/#multi-dimensional-processing","title":"Multi-dimensional Processing","text":"<ol> <li>Design dimension-aware workflows: Structure processes to operate on appropriate dimensions (temporal vs spectral)</li> <li>Maintain dimensional consistency: Ensure operations preserve or appropriately transform dimensional structure</li> <li>Use factory methods: Leverage <code>RasterStack.from_images()</code> and <code>.first</code>/<code>.last</code> properties for consistent handling</li> </ol>"},{"location":"raster-stack/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<ol> <li>Configure exception handling: Set appropriate <code>allowed_exceptions</code> for robust data loading</li> <li>Handle temporal gaps: Design workflows that gracefully handle missing temporal observations</li> <li>Test with diverse data: Validate performance with various temporal resolutions and band combinations</li> </ol>"},{"location":"release-notes/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"release-notes/#unreleased","title":"Unreleased","text":""},{"location":"release-notes/#080-2026-01-12","title":"[0.8.0] (2026-01-12)","text":""},{"location":"release-notes/#added","title":"Added","text":"<ul> <li>BREAKING: Comprehensive parameter management system for both <code>/result</code> and XYZ tile service endpoints #165</li> <li>Dynamic query parameter support with JSON parsing and type conversion</li> <li>Default parameter values from process graph definitions  </li> <li>Automatic injection of system parameters (<code>_openeo_user</code>, spatial context)</li> <li>Parameter precedence hierarchy: query params \u2192 system params \u2192 defaults</li> <li>Unified parameter handling across synchronous and tile service endpoints</li> </ul>"},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>BREAKING: User parameter injection now uses reserved <code>_openeo_user</code> parameter name instead of <code>user</code> #165 </li> <li>Update process graphs that reference user information to use <code>{\"from_parameter\": \"_openeo_user\"}</code></li> <li>The <code>user</code> parameter name is no longer automatically mapped to the authenticated user</li> <li>BREAKING: Enhanced parameter validation and processing may affect existing process graphs #165</li> <li>Default parameter values are now consistently applied when parameters are missing</li> <li>Query parameters undergo strict JSON parsing and type validation</li> <li>Parameter substitution now uses OpenEO standard built-in mechanisms</li> </ul>"},{"location":"release-notes/#070-2025-12-10","title":"0.7.0 (2025-12-10)","text":""},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>keep CRS/Bounds for STAC Item is not all proj attributes are set in properties #154</li> <li>Fix LazyRasterStack uniqueness and add temporal ordering #157</li> </ul>"},{"location":"release-notes/#added_1","title":"Added","text":"<ul> <li>Full User Defined Process Graph support including graph validation #158</li> <li>Implement truly lazy execution for LazyRasterStack #161</li> <li>Add support for environment variables from Secrets and ConfigMaps #160</li> </ul>"},{"location":"release-notes/#061-2025-12-04","title":"[0.6.1] (2025-12-04)","text":""},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>replace custom <code>BoundingBox</code> with <code>BoundingBox</code> from openEO pg_schema to fix type validation errors</li> </ul>"},{"location":"release-notes/#060-2025-12-04","title":"0.6.0 (2025-12-04)","text":""},{"location":"release-notes/#changed_1","title":"Changed","text":"<ul> <li>move <code>get_load_collection_nodes</code> and <code>resolves_process_graph_parameters</code> method within the <code>EndpointsFactory</code> class</li> <li>rename <code>get_load_collection_nodes</code> to <code>get_load_nodes</code></li> </ul>"},{"location":"release-notes/#added_2","title":"Added","text":"<ul> <li>add <code>load_nodes_ids</code> attribute in <code>EndpointsFactory</code> </li> <li>add STAC <code>extras</code> for STACReader asset's info (e.g Band/proj extensions)</li> </ul>"},{"location":"release-notes/#fixed_2","title":"Fixed","text":"<ul> <li>overwrite <code>loader nodes</code> spatial extent when creating a XYZ service</li> </ul>"},{"location":"release-notes/#050-2025-11-05","title":"0.5.0 (2025-11-05)","text":""},{"location":"release-notes/#fixed_3","title":"Fixed","text":"<ul> <li>improve relative imports to avoid circular dependencies</li> </ul>"},{"location":"release-notes/#040-2025-11-04","title":"0.4.0 (2025-11-04)","text":""},{"location":"release-notes/#added_3","title":"Added","text":"<ul> <li>Add user tracking functionality across all store implementations (SQLAlchemy, DuckDB, Local) to monitor user authentication history and activity</li> <li>Update <code>titiler</code> dependency to <code>&gt;=0.24.0,&lt;0.25</code></li> <li>Update <code>openeo-pg-parser-networkx</code> to <code>==2025.10.1</code></li> </ul>"},{"location":"release-notes/#030-2025-06-04","title":"0.3.0 (2025-06-04)","text":""},{"location":"release-notes/#added_4","title":"Added","text":"<ul> <li>Added force-release functionality for tile assignment and update documentation #96</li> <li>Added tile update functionality #97</li> <li>Add width and height parameters to load_collection and load_collection_and_reduce processes #99</li> <li>Add tiles_summary process and implement get_all_tiles method in TileAssignmentStore #101</li> <li>Add max and min functions with no-data handling #102</li> </ul>"},{"location":"release-notes/#fixed_4","title":"Fixed","text":"<ul> <li>Enhances pixel limit check to avoid double counting mosaic items by grouping them by datetime. #98</li> </ul>"},{"location":"release-notes/#changed_2","title":"Changed","text":"<ul> <li>Refactor tile assignment and add spatial extent handling #100</li> <li>Refactor STAC reader and enhance output dimension handling #103</li> <li>Refactor STAC item handling and enhance metadata retrieval #104</li> </ul>"},{"location":"release-notes/#021-2025-05-21","title":"0.2.1 (2025-05-21)","text":""},{"location":"release-notes/#added_5","title":"Added","text":"<ul> <li>Added force-release functionality for tile assignment to release tiles regardless of state</li> </ul>"},{"location":"release-notes/#changed_3","title":"Changed","text":"<ul> <li>Fix load_collection to properly merge items from same date to maintain strict temporal dimension #93</li> <li>Improve error handling for output size limits with clearer error messages and proper pixel count calculation #94</li> </ul>"},{"location":"release-notes/#020-2025-05-19","title":"0.2.0 (2025-05-19)","text":""},{"location":"release-notes/#added_6","title":"Added","text":"<ul> <li>OpenEO process graph to CQL2-JSON conversion feature #65</li> <li>Output size estimation and validation #58</li> <li>NDWI process implementation #67</li> <li><code>load_url</code> process for direct COG loading #70</li> <li>PostgreSQL subchart support #73</li> <li>Support for default services configuration #74</li> <li>DynamicCacheControlMiddleware for improved cache management #78</li> <li>Tile assignment functionality with SQLAlchemy integration #80</li> <li>Service authorization management for restricted access #81</li> <li>get_param_item process for JSONPath extraction #82</li> </ul>"},{"location":"release-notes/#changed_4","title":"Changed","text":"<ul> <li>Implement lazy rasterstack #62</li> <li>Refactor processes to standardize data types to 'datacube' #68</li> <li>Enhance navigation structure and improve documentation readability #72</li> <li>Enhance service input validation and handling logic #77</li> <li>Enhance process nodes with user parameter handling #79</li> <li>Enhance tile assignment process with user control #83</li> <li>Enhance user parameter handling in processes #84</li> </ul>"},{"location":"release-notes/#fixed_5","title":"Fixed","text":"<ul> <li>Add check for version sync #49</li> </ul>"},{"location":"release-notes/#010-2025-04-07","title":"0.1.0 (2025-04-07)","text":"<p>Initial release of openEO by TiTiler</p>"},{"location":"tile-assignment/","title":"Tile Assignment","text":"<p>The tile assignment feature allows services to manage and track XYZ tile assignments to users. This is particularly useful for scenarios where you need to coordinate work across multiple users, ensuring each user works on unique tiles without overlap.</p>"},{"location":"tile-assignment/#setup","title":"Setup","text":"<p>The tile assignment feature requires two levels of configuration:</p> <ol> <li>Global Configuration:</li> </ol> <pre><code># Enable tile assignment with SQLAlchemy store\nTITILER_OPENEO_TILE_STORE_URL=postgresql://user:pass@host/db\n</code></pre> <ol> <li>Service Configuration:</li> </ol> <pre><code>{\n  \"type\": \"XYZ\",\n  \"configuration\": {\n    \"tile_store\": true,\n    ...other configuration options...\n  }\n}\n</code></pre> <p>The feature will only be active when both:</p> <ul> <li>A valid tile store URL is configured at the system level</li> <li>The service has <code>tile_store: true</code> in its configuration (this will inject the store as \"_openeo_tile_store\" parameter)</li> </ul> <p>To access the injected tile store in your process graph, use the <code>from_parameter</code> reference:</p> <pre><code>{\n  \"process_graph\": {\n    \"tile_assignment1\": {\n      \"process_id\": \"tile_assignment\",\n      \"arguments\": {\n        \"store\": {\n          \"from_parameter\": \"_openeo_tile_store\"\n        },\n        \"zoom\": 12,\n        \"x_range\": [1000, 1010],\n        \"y_range\": [2000, 2010],\n        \"stage\": \"claim\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"tile-assignment/#supported-store-types","title":"Supported Store Types","text":"<p>Currently supported tile store implementations:</p> <ul> <li>PostgreSQL: <code>postgresql://user:pass@host/db</code></li> <li>SQLite: <code>sqlite:///path/to/db.sqlite</code></li> <li>SQLAlchemy URL: <code>sqlalchemy://...</code></li> </ul>"},{"location":"tile-assignment/#process-parameters","title":"Process Parameters","text":"<p>The tile assignment process is defined with the following JSON schema:</p> <pre><code>{\n  \"parameters\": {\n    \"zoom\": {\n      \"description\": \"Fixed zoom level for tile assignment\",\n      \"type\": \"integer\",\n      \"required\": true\n    },\n    \"x_range\": {\n      \"description\": \"Range of possible X values [min, max]\",\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"minItems\": 2,\n      \"maxItems\": 2,\n      \"required\": true\n    },\n    \"y_range\": {\n      \"description\": \"Range of possible Y values [min, max]\",\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"minItems\": 2,\n      \"maxItems\": 2,\n      \"required\": true\n    },\n    \"stage\": {\n      \"description\": \"Stage of tile assignment\",\n      \"type\": \"string\",\n      \"enum\": [\"claim\", \"release\", \"submit\", \"force-release\"],\n      \"required\": true\n    },\n    \"user_id\": {\n      \"description\": \"User identifier for tile assignment\",\n      \"type\": \"string\",\n      \"required\": true\n    },\n  }\n}\n</code></pre> <p>Because <code>user_id</code> is defined with <code>\"type\": \"string\"</code>, when using <code>from_parameter: \"_openeo_user\"</code>, it will automatically extract just the user ID from the User object.</p>"},{"location":"tile-assignment/#access-control","title":"Access Control","text":"<p>The tile assignment process ensures that each tile can only be managed by the user who claimed it. Each operation (release/submit/force-release) requires a valid tile assignment - a user must have a claimed tile to perform any operation on it.</p>"},{"location":"tile-assignment/#usage-example","title":"Usage Example","text":"<p>Here's an example of using the tile assignment process in a service:</p> <pre><code>{\n  \"process_graph\": {\n    \"tile_assignment1\": {\n      \"process_id\": \"tile_assignment\",\n      \"arguments\": {\n        \"zoom\": 12,\n        \"x_range\": [1000, 1010],\n        \"y_range\": [2000, 2010],\n        \"stage\": \"claim\",\n        \"user_id\": \"user123\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"tile-assignment/#workflow","title":"Workflow","text":"<ol> <li>Claiming a Tile:</li> <li>User requests a tile with stage=\"claim\"</li> <li>System randomly assigns an available tile within the specified ranges</li> <li>If user already has a tile assigned, returns that tile instead</li> <li> <p>If no tiles are available, raises an error</p> </li> <li> <p>Releasing a Tile:</p> </li> <li>User releases their tile with stage=\"release\"</li> <li>Tile becomes available for other users to claim</li> <li>Cannot release a submitted tile without force-release</li> <li>Only the owner can release their tile</li> <li> <p>Error if another user tries to release it</p> </li> <li> <p>Submitting a Tile:</p> </li> <li>User submits their tile with stage=\"submit\"</li> <li>Tile becomes locked and cannot be released normally</li> <li>Only the owner of the tile can submit it</li> <li> <p>Submitted tiles can only be released using force-release</p> </li> <li> <p>Force-releasing a Tile:</p> </li> <li>User can force-release their tile with stage=\"force-release\"</li> <li>Works on any tile state (claimed or submitted)</li> <li>Only the owner of the tile can force-release it</li> <li> <p>Useful for recovering tiles that are stuck in submitted state</p> </li> <li> <p>Updating a Tile:</p> </li> <li>User can add or update additional information to their assigned tile</li> <li>Supports arbitrary JSON data for tracking progress, metadata, etc.</li> <li>Additional data persists and is returned in subsequent queries</li> <li>Only the tile owner can update their tile in controlled mode</li> <li>Common use cases:<ul> <li>Progress tracking (e.g., percent complete)</li> <li>Processing metadata (start time, end time)</li> <li>Quality metrics</li> <li>Custom workflow data</li> </ul> </li> </ol>"},{"location":"tile-assignment/#error-handling","title":"Error Handling","text":"<p>The process handles several error conditions:</p> <ul> <li><code>NoTileAvailableError</code>: When trying to claim a tile but none are available</li> <li><code>TileNotAssignedError</code>: When trying to release/submit a tile but user has none assigned</li> <li><code>TileAlreadyLockedError</code>: When trying to release a submitted tile</li> </ul>"},{"location":"tile-assignment/#implementation-details","title":"Implementation Details","text":"<p>The tile assignment system:</p> <ul> <li>Maintains persistent tile assignments using SQLAlchemy</li> <li>Ensures unique tile assignments (no two users can have the same tile)</li> <li>Randomly distributes tiles to prevent predictable assignment patterns</li> <li>Supports multiple services with independent tile assignments</li> <li>Tracks tile state (claimed/released/submitted)</li> </ul>"},{"location":"tile-assignment/#best-practices","title":"Best Practices","text":"<ol> <li>Range Selection:</li> <li>Choose appropriate x_range and y_range based on your data coverage</li> <li>Consider zoom level when determining range size</li> <li> <p>Avoid overlapping ranges between different services</p> </li> <li> <p>Error Handling:</p> </li> <li>Always handle potential errors in your client code</li> <li>Implement retry logic for NoTileAvailableError</li> <li> <p>Verify tile assignment before starting work</p> </li> <li> <p>State Management:</p> </li> <li>Submit completed tiles to prevent accidental release</li> <li>Release tiles when work is abandoned</li> <li>Check existing assignments before claiming new tiles</li> </ol>"},{"location":"type-validation/","title":"Type Validation in OpenEO Process Implementations","text":""},{"location":"type-validation/#overview","title":"Overview","text":"<p>The OpenEO process implementations in <code>titiler/openeo/processes/implementations/</code> now include automatic runtime type validation using Pydantic. This helps catch type errors early, such as passing a <code>RasterStack</code> to a function that expects an array-like object.</p>"},{"location":"type-validation/#how-it-works","title":"How It Works","text":""},{"location":"type-validation/#automatic-validation","title":"Automatic Validation","text":"<p>The <code>@process</code> decorator automatically validates parameter types based on function signatures:</p> <pre><code>@process\ndef array_create(data: Optional[ArrayLike] = None, repeat: int = 1) -&gt; ArrayLike:\n    \"\"\"Creates a new array.\"\"\"\n    # Type validation happens automatically before this code runs\n    if data is None:\n        return numpy.empty((1, 1, 1), dtype=numpy.uint8)\n    return numpy.asanyarray(data)\n</code></pre>"},{"location":"type-validation/#type-checking-features","title":"Type Checking Features","text":"<ol> <li>Type Annotations as Source of Truth: Function type hints define expected types</li> <li>Pydantic Validation: Leverages Pydantic's <code>TypeAdapter</code> for runtime validation</li> <li>Special Handling for Common Mistakes:</li> <li>Detects when <code>RasterStack</code> (dict) is passed to array-like parameters</li> <li>Provides clear, actionable error messages</li> </ol>"},{"location":"type-validation/#example-error-messages","title":"Example Error Messages","text":"<p>When a user passes a <code>RasterStack</code> to <code>array_create</code>:</p> <pre><code>TypeError: Parameter 'data' in process 'array_create' expected \n'Union[ArrayLike, None]' but got 'dict'. RasterStack/dict types \nare not compatible with array-like parameters.\n</code></pre>"},{"location":"type-validation/#validation-rules","title":"Validation Rules","text":""},{"location":"type-validation/#what-gets-validated","title":"What Gets Validated","text":"<ul> <li>All parameters with type annotations</li> <li>Parameters resolved through OpenEO's parameter reference system</li> <li>Optional types (allows <code>None</code> when appropriate)</li> </ul>"},{"location":"type-validation/#what-doesnt-get-validated","title":"What Doesn't Get Validated","text":"<ul> <li>Parameters without type annotations</li> <li>Parameters with <code>Any</code> type</li> <li>Special internal parameters (e.g., <code>_openeo_user</code>)</li> </ul>"},{"location":"type-validation/#type-compatibility","title":"Type Compatibility","text":"<p>The validation system understands:</p> <ul> <li>Optional types: <code>Optional[ArrayLike]</code> accepts <code>None</code> or array-like values</li> <li>Union types: <code>Union[int, float]</code> accepts either integers or floats</li> <li>Generic types: <code>Dict[datetime, ImageData]</code> for RasterStack</li> <li>Custom types: <code>RasterStack</code>, <code>ArrayLike</code></li> </ul>"},{"location":"type-validation/#common-type-errors","title":"Common Type Errors","text":""},{"location":"type-validation/#rasterstack-vs-arraylike","title":"RasterStack vs ArrayLike","text":"<p>Problem: Passing a <code>RasterStack</code> to a function expecting arrays</p> <pre><code># \u274c This will raise a TypeError\nfrom datetime import datetime\nraster_stack = {datetime(2023, 1, 1): ImageData(...)}\nresult = array_create(data=raster_stack)\n</code></pre> <p>Solution: Use the correct input type</p> <pre><code># \u2705 Pass an array instead\nresult = array_create(data=[1, 2, 3])\n</code></pre>"},{"location":"type-validation/#none-for-required-parameters","title":"None for Required Parameters","text":"<p>Problem: Passing <code>None</code> to non-optional parameters</p> <pre><code># \u274c This will raise a TypeError if 'data' is not Optional\nresult = some_process(data=None)\n</code></pre> <p>Solution: Check if the parameter is Optional in the function signature</p>"},{"location":"type-validation/#implementation-details","title":"Implementation Details","text":""},{"location":"type-validation/#the-process-decorator","title":"The @process Decorator","text":"<p>The <code>@process</code> decorator in <code>titiler/openeo/processes/implementations/core.py</code>:</p> <ol> <li>Resolves parameter references</li> <li>Extracts type annotations from function signature</li> <li>Validates each parameter using <code>_validate_parameter_types()</code></li> <li>Executes the function if all validations pass</li> </ol>"},{"location":"type-validation/#validation-function","title":"Validation Function","text":"<p>The <code>_validate_parameter_types()</code> function:</p> <ul> <li>Checks for None values in non-Optional parameters</li> <li>Detects dict/RasterStack being passed to non-dict parameters</li> <li>Uses Pydantic's TypeAdapter for general validation</li> <li>Gracefully skips validation for complex types Pydantic can't handle</li> </ul>"},{"location":"type-validation/#performance-considerations","title":"Performance Considerations","text":"<p>Type validation adds minimal overhead:</p> <ul> <li>Validation only runs for decorated functions</li> <li>Failed validations raise errors early, preventing downstream issues</li> <li>Pydantic's TypeAdapter is efficient for most common types</li> </ul>"},{"location":"type-validation/#testing-type-validation","title":"Testing Type Validation","text":"<p>Example test to verify type validation:</p> <pre><code>from titiler.openeo.processes.implementations.arrays import array_create\nfrom titiler.openeo.processes.implementations.data_model import RasterStack\n\ndef test_array_create_rejects_raster_stack():\n    \"\"\"Verify that array_create rejects RasterStack input.\"\"\"\n    raster_stack: RasterStack = {\n        \"band1\": ImageData(\n            np.array([[[1, 2], [3, 4]]]),\n            bounds=(0, 0, 1, 1),\n            crs=\"EPSG:4326\"\n        )\n    }\n\n    with pytest.raises(TypeError) as exc_info:\n        array_create(data=raster_stack)\n\n    assert \"RasterStack/dict types are not compatible\" in str(exc_info.value)\n</code></pre>"},{"location":"type-validation/#adding-type-validation-to-new-processes","title":"Adding Type Validation to New Processes","text":"<p>To add type validation to a new process:</p> <ol> <li>Add the @process decorator:</li> </ol> <pre><code>from .core import process\n\n@process\ndef my_process(data: ArrayLike, scale: float) -&gt; ArrayLike:\n    ...\n</code></pre> <ol> <li>Use proper type hints:</li> <li>Use <code>ArrayLike</code> for array inputs</li> <li>Use <code>RasterStack</code> for dict inputs</li> <li>Use <code>Optional[T]</code> for optional parameters</li> <li> <p>Use <code>Union[T1, T2]</code> for multiple accepted types</p> </li> <li> <p>Test edge cases:</p> </li> <li>Test with None values</li> <li>Test with wrong types</li> <li>Test with valid inputs</li> </ol>"},{"location":"type-validation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"type-validation/#validationerror-from-pydantic","title":"ValidationError from Pydantic","text":"<p>If you see a Pydantic <code>ValidationError</code>, check:</p> <ol> <li>The expected type in the function signature</li> <li>The actual type being passed</li> <li>Whether the types are compatible</li> </ol>"},{"location":"type-validation/#could-not-validate-type-debug-messages","title":"\"Could not validate type\" Debug Messages","text":"<p>These are logged when Pydantic can't validate a complex type. This is usually fine and the validation is skipped for those parameters.</p>"},{"location":"type-validation/#subscripted-generics-error","title":"Subscripted Generics Error","text":"<p>If you see \"Subscripted generics cannot be used with class and instance checks\":</p> <ul> <li>This happens when using type aliases like <code>RasterStack</code> in <code>isinstance()</code> checks</li> <li>The validation code handles this correctly by checking for <code>dict</code> instead</li> </ul>"},{"location":"type-validation/#future-enhancements","title":"Future Enhancements","text":"<p>Possible improvements:</p> <ul> <li>Add validation for return types</li> <li>Create more specific error messages for common mistakes</li> <li>Add configuration to enable/disable validation per process</li> <li>Support for custom validation rules per parameter</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using openEO by TiTiler for various Earth Observation tasks.</p>"},{"location":"examples/#web-editor-examples","title":"Web Editor Examples","text":"<p>The openEO Web Editor provides a graphical interface for interacting with the API. To get started:</p> <ol> <li>Start the services:</li> </ol> <pre><code>docker compose up\n</code></pre> <ol> <li> <p>Access the editor at localhost:8080 and set the backend URL to localhost:8081</p> </li> <li> <p>Authenticate using the instructions in the Admin Guide</p> </li> </ol>"},{"location":"examples/#jupyter-notebook-examples","title":"Jupyter Notebook Examples","text":"<p>We provide several Jupyter notebooks demonstrating different use cases:</p>"},{"location":"examples/#manhattan-satellite-imagery","title":"Manhattan Satellite Imagery","text":"<p>Learn how to:</p> <ul> <li>Connect to the openEO backend</li> <li>Load and process Sentinel-2 imagery using default resolution (1024 pixels width)</li> <li>Control output resolution with explicit width/height parameters</li> <li>Create true-color RGB visualizations</li> <li>Apply color enhancements for better visualization</li> </ul>"},{"location":"examples/#ndvi-time-series-analysis","title":"NDVI Time Series Analysis","text":"<p>Explore how to:</p> <ul> <li>Calculate vegetation indices (NDVI)</li> <li>Extract time series data for specific areas</li> <li>Control memory usage with appropriate resolution settings</li> <li>Analyze temporal patterns in vegetation</li> <li>Visualize results using matplotlib</li> </ul>"},{"location":"examples/#resolution-control-examples","title":"Resolution Control Examples","text":"<p>The examples demonstrate different approaches to managing resolution:</p> <ol> <li>Default Resolution (Recommended):</li> </ol> <pre><code>loadcol = load_collection(\n    \"SENTINEL2_L2A\",\n    spatial_extent=bbox,\n    temporal_extent=[\"2021-01-01\", \"2021-12-31\"],\n    bands=[\"B04\", \"B08\"]\n)\n# Reduce temporal dimension\nreduced = reduce_dimension(loadcol, dimension=\"time\", reducer=\"first\")\n# Uses default width of 1024 pixels for memory efficiency\n</code></pre> <ol> <li>Custom Resolution:</li> </ol> <pre><code>loadcol = load_collection(\n    \"SENTINEL2_L2A\",\n    spatial_extent=bbox,\n    temporal_extent=[\"2021-01-01\", \"2021-12-31\"],\n    bands=[\"B04\", \"B08\"],\n    width=2048,  # Explicitly control resolution\n)\nreduced = reduce_dimension(loadcol, dimension=\"time\", reducer=\"first\")\n</code></pre> <p>Note: The <code>load_collection_and_reduce</code> process is deprecated. Use <code>load_collection</code> followed by <code>reduce_dimension</code> as shown above.</p>"},{"location":"examples/#running-the-notebooks","title":"Running the Notebooks","text":"<p>To run the notebooks locally:</p> <ol> <li>Install the development dependencies:</li> </ol> <pre><code>python -m pip install -e \".[dev]\"\n</code></pre> <ol> <li>Start Jupyter:</li> </ol> <pre><code>jupyter notebook docs/notebooks\n</code></pre> <ol> <li>Open the desired notebook and follow the instructions</li> </ol>"},{"location":"examples/#parameter-management","title":"Parameter Management","text":"<p>For examples of using the comprehensive parameter management system (query parameters, defaults, validation), see the Parameter Management documentation.</p>"},{"location":"examples/parameter-management/","title":"Parameter Management Examples","text":"<p>This file provides practical examples of the parameter management features in openEO by TiTiler.</p>"},{"location":"examples/parameter-management/#basic-query-parameters","title":"Basic Query Parameters","text":""},{"location":"examples/parameter-management/#simple-parameter-override","title":"Simple Parameter Override","text":"<pre><code># Basic parameter substitution\ncurl -X POST \"http://localhost:8081/result?collection=L8&amp;temporal_extent=[\\\"2024-01-01\\\",\\\"2024-06-30\\\"]\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": {\"from_parameter\": \"collection\"},\n            \"temporal_extent\": {\"from_parameter\": \"temporal_extent\"},\n            \"spatial_extent\": {\n              \"west\": 16.1,\n              \"east\": 16.6,\n              \"north\": 48.6,\n              \"south\": 47.2\n            }\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"collection\",\n          \"schema\": {\"type\": \"string\"},\n          \"default\": \"S2\"\n        },\n        {\n          \"name\": \"temporal_extent\",\n          \"schema\": {\"type\": \"array\"},\n          \"default\": [\"2023-01-01\", \"2023-12-31\"]\n        }\n      ]\n    }\n  }'\n</code></pre>"},{"location":"examples/parameter-management/#complex-object-parameters","title":"Complex Object Parameters","text":"<pre><code># Using complex JSON objects as parameters\ncurl -X POST \"http://localhost:8081/result?bounding_box={\\\"west\\\":10,\\\"east\\\":20,\\\"north\\\":50,\\\"south\\\":40}&amp;bands=[\\\"B04\\\",\\\"B03\\\",\\\"B02\\\"]\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": \"S2\",\n            \"spatial_extent\": {\"from_parameter\": \"bounding_box\"},\n            \"bands\": {\"from_parameter\": \"bands\"},\n            \"temporal_extent\": [\"2024-01-01\", \"2024-06-30\"]\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"bounding_box\",\n          \"description\": \"Spatial bounding box\",\n          \"schema\": {\n            \"type\": \"object\",\n            \"required\": [\"west\", \"east\", \"north\", \"south\"],\n            \"properties\": {\n              \"west\": {\"type\": \"number\"},\n              \"east\": {\"type\": \"number\"},\n              \"north\": {\"type\": \"number\"},\n              \"south\": {\"type\": \"number\"}\n            }\n          },\n          \"default\": {\n            \"west\": 16.1,\n            \"east\": 16.6,\n            \"north\": 48.6,\n            \"south\": 47.2\n          }\n        },\n        {\n          \"name\": \"bands\",\n          \"schema\": {\"type\": \"array\"},\n          \"default\": [\"B04\", \"B08\"]\n        }\n      ]\n    }\n  }'\n</code></pre>"},{"location":"examples/parameter-management/#xyz-tile-service-parameters","title":"XYZ Tile Service Parameters","text":""},{"location":"examples/parameter-management/#create-parameterized-xyz-service","title":"Create Parameterized XYZ Service","text":"<pre><code># Create a service with bounding_box parameter\ncurl -X POST \"http://localhost:8081/services\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": \"S2\",\n            \"spatial_extent\": {\"from_parameter\": \"bounding_box\"},\n            \"temporal_extent\": {\"from_parameter\": \"time_range\"},\n            \"bands\": {\"from_parameter\": \"bands\"}\n          }\n        },\n        \"save1\": {\n          \"process_id\": \"save_result\",\n          \"arguments\": {\n            \"data\": {\"from_node\": \"load1\"},\n            \"format\": \"PNG\"\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"time_range\",\n          \"description\": \"Temporal extent for data loading\",\n          \"schema\": {\"type\": \"array\"},\n          \"default\": [\"2023-01-01\", \"2023-12-31\"]\n        },\n        {\n          \"name\": \"bands\",\n          \"description\": \"Spectral bands to load\",\n          \"schema\": {\"type\": \"array\"},\n          \"default\": [\"B04\", \"B03\", \"B02\"]\n        }\n      ]\n    },\n    \"type\": \"XYZ\",\n    \"title\": \"Parameterized Sentinel-2 Service\"\n  }'\n</code></pre>"},{"location":"examples/parameter-management/#use-xyz-service-with-parameters","title":"Use XYZ Service with Parameters","text":"<pre><code># Access tiles with custom parameters\ncurl \"http://localhost:8081/services/xyz/{service_id}/tiles/10/512/341?time_range=[\\\"2024-06-01\\\",\\\"2024-06-30\\\"]&amp;bands=[\\\"B08\\\",\\\"B04\\\",\\\"B03\\\"]\" \\\n  -H \"Authorization: Bearer test\" \\\n  -o tile.png\n</code></pre>"},{"location":"examples/parameter-management/#deprecated-individual-spatial-parameters","title":"Deprecated: Individual Spatial Parameters","text":"<p>\u26a0\ufe0f Deprecated: The <code>spatial_extent_*</code> parameters are deprecated and will be removed in a future release. Use the <code>bounding_box</code> parameter instead.</p> <p>For backward compatibility, you can still use individual spatial extent parameters:</p> <pre><code>{\n  \"spatial_extent\": {\n    \"west\": {\"from_parameter\": \"spatial_extent_west\"},\n    \"east\": {\"from_parameter\": \"spatial_extent_east\"},\n    \"north\": {\"from_parameter\": \"spatial_extent_north\"},\n    \"south\": {\"from_parameter\": \"spatial_extent_south\"}\n  }\n}\n</code></pre> <p>These individual parameters (<code>spatial_extent_west</code>, <code>spatial_extent_east</code>, etc.) are automatically provided by the system for XYZ tile services, but using the <code>bounding_box</code> parameter is recommended for new implementations.</p>"},{"location":"examples/parameter-management/#user-context-examples","title":"User Context Examples","text":""},{"location":"examples/parameter-management/#process-with-user-information","title":"Process with User Information","text":"<pre><code># Process that uses authenticated user information\ncurl -X POST \"http://localhost:8081/result\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": \"S2\",\n            \"spatial_extent\": {\n              \"west\": 16.1,\n              \"east\": 16.6,\n              \"north\": 48.6,\n              \"south\": 47.2\n            },\n            \"temporal_extent\": [\"2024-01-01\", \"2024-06-30\"]\n          }\n        },\n        \"user_filter\": {\n          \"process_id\": \"custom_user_process\",\n          \"arguments\": {\n            \"data\": {\"from_node\": \"load1\"},\n            \"user\": {\"from_parameter\": \"_openeo_user\"}\n          },\n          \"result\": true\n        }\n      }\n    }\n  }'\n</code></pre>"},{"location":"examples/parameter-management/#parameter-validation-examples","title":"Parameter Validation Examples","text":""},{"location":"examples/parameter-management/#schema-validation","title":"Schema Validation","text":"<pre><code># Parameters with strict validation\ncurl -X POST \"http://localhost:8081/result?cloud_cover=15&amp;processing_level=L2A\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": \"S2\",\n            \"spatial_extent\": {\n              \"west\": 16.1,\n              \"east\": 16.6,\n              \"north\": 48.6,\n              \"south\": 47.2\n            },\n            \"temporal_extent\": [\"2024-01-01\", \"2024-06-30\"],\n            \"properties\": {\n              \"cloud_cover\": {\"lte\": {\"from_parameter\": \"cloud_cover\"}},\n              \"processing_level\": {\"eq\": {\"from_parameter\": \"processing_level\"}}\n            }\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"cloud_cover\",\n          \"description\": \"Maximum cloud cover percentage\",\n          \"schema\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100\n          },\n          \"default\": 20\n        },\n        {\n          \"name\": \"processing_level\",\n          \"description\": \"Sentinel-2 processing level\",\n          \"schema\": {\n            \"type\": \"string\",\n            \"enum\": [\"L1C\", \"L2A\"]\n          },\n          \"default\": \"L2A\"\n        }\n      ]\n    }\n  }'\n</code></pre>"},{"location":"examples/parameter-management/#error-handling","title":"Error Handling","text":""},{"location":"examples/parameter-management/#parameter-validation-errors","title":"Parameter Validation Errors","text":"<pre><code># This will fail validation (cloud_cover &gt; 100)\ncurl -X POST \"http://localhost:8081/result?cloud_cover=150\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"id\": \"S2\",\n            \"properties\": {\n              \"cloud_cover\": {\"lte\": {\"from_parameter\": \"cloud_cover\"}}\n            }\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"cloud_cover\",\n          \"schema\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100\n          }\n        }\n      ]\n    }\n  }'\n\n# Response: 422 Unprocessable Entity with validation details\n</code></pre>"},{"location":"examples/parameter-management/#invalid-json-parameters","title":"Invalid JSON Parameters","text":"<pre><code># This will fail due to malformed JSON\ncurl -X POST \"http://localhost:8081/result?bounding_box={invalid-json}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer test\" \\\n  -d '{\n    \"process\": {\n      \"process_graph\": {\n        \"load1\": {\n          \"process_id\": \"load_collection\",\n          \"arguments\": {\n            \"spatial_extent\": {\"from_parameter\": \"bounding_box\"}\n          },\n          \"result\": true\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"bounding_box\",\n          \"schema\": {\"type\": \"object\"}\n        }\n      ]\n    }\n  }'\n\n# Response: 400 Bad Request with JSON parsing error details\n</code></pre>"},{"location":"examples/parameter-management/#migration-from-previous-versions","title":"Migration from Previous Versions","text":""},{"location":"examples/parameter-management/#update-user-parameter-references","title":"Update User Parameter References","text":"<pre><code># OLD: Using \"user\" parameter (no longer works)\n{\n  \"arguments\": {\n    \"user_data\": {\"from_parameter\": \"user\"}\n  }\n}\n\n# NEW: Using \"_openeo_user\" reserved parameter\n{\n  \"arguments\": {\n    \"user_data\": {\"from_parameter\": \"_openeo_user\"}\n  }\n}\n</code></pre>"},{"location":"examples/parameter-management/#parameter-definition-migration","title":"Parameter Definition Migration","text":"<pre><code># OLD: Manual parameter handling (deprecated)\n# Parameters were passed but not formally defined\n\n# NEW: Formal parameter definitions with validation\n{\n  \"process_graph\": { ... },\n  \"parameters\": [\n    {\n      \"name\": \"my_param\",\n      \"description\": \"Parameter description\",\n      \"schema\": {\"type\": \"string\"},\n      \"default\": \"default_value\"\n    }\n  ]\n}\n</code></pre>"},{"location":"notebooks/evi/","title":"Enhanced Vegetation Index (EVI)","text":"In\u00a0[11]: Copied! <pre>import matplotlib.pyplot as plt\nimport rasterio\nimport openeo\nfrom matplotlib.colors import LinearSegmentedColormap\n</pre> import matplotlib.pyplot as plt import rasterio import openeo from matplotlib.colors import LinearSegmentedColormap In\u00a0[12]: Copied! <pre># Connect to the OpenEO backend and authenticate\n# connection = openeo.connect(\n#     url=\"https://openeo.ds.io\"\n# ).authenticate_oidc_authorization_code()\n\nconnection = openeo.connect(\n    url=\"http://127.0.0.1:8081/\"\n).authenticate_oidc_authorization_code()\n</pre> # Connect to the OpenEO backend and authenticate # connection = openeo.connect( #     url=\"https://openeo.ds.io\" # ).authenticate_oidc_authorization_code()  connection = openeo.connect(     url=\"http://127.0.0.1:8081/\" ).authenticate_oidc_authorization_code() In\u00a0[13]: Copied! <pre># Define data collection parameters\ncollection_id = \"sentinel-2-l2a\"\n\n# Define spatial extent (South Tyrol, Italy)\nspat_ext = {\"west\": 11.27, \"east\": 11.40, \"south\": 46.46, \"north\": 46.52}\n\n# Define time range (June 2018)\ntime_range = [\"2018-06-04\", \"2018-06-10\"]\n\n# Select required bands\nbands = [\"B08_10m\", \"B04_10m\", \"B02_10m\"]\n\n# Create datacube\ns2 = connection.datacube_from_process(\n    \"load_collection\",\n    id=collection_id,\n    spatial_extent=spat_ext,\n    temporal_extent=time_range,\n    bands=bands,\n    width=None,\n)\n</pre> # Define data collection parameters collection_id = \"sentinel-2-l2a\"  # Define spatial extent (South Tyrol, Italy) spat_ext = {\"west\": 11.27, \"east\": 11.40, \"south\": 46.46, \"north\": 46.52}  # Define time range (June 2018) time_range = [\"2018-06-04\", \"2018-06-10\"]  # Select required bands bands = [\"B08_10m\", \"B04_10m\", \"B02_10m\"]  # Create datacube s2 = connection.datacube_from_process(     \"load_collection\",     id=collection_id,     spatial_extent=spat_ext,     temporal_extent=time_range,     bands=bands,     width=None, ) In\u00a0[14]: Copied! <pre># Extract individual bands\nb02 = s2.band(2).divide(10000)  # Blue\nb04 = s2.band(1).divide(10000)  # Red\nb08 = s2.band(0).divide(10000)  # NIR\n\n# Calculate EVI\nevi = 2.5 * ((b08 - b04) / (b08 + 6 * b04 - 7.5 * b02 + 1))\n\n# Get minimum EVI value over time period\nmin_evi = evi.min_time()\n\n# Save result\noutput = min_evi.download(\"evi.tif\", format=\"GTiff\", options={\"compress\": \"DEFLATE\"})\n</pre> # Extract individual bands b02 = s2.band(2).divide(10000)  # Blue b04 = s2.band(1).divide(10000)  # Red b08 = s2.band(0).divide(10000)  # NIR  # Calculate EVI evi = 2.5 * ((b08 - b04) / (b08 + 6 * b04 - 7.5 * b02 + 1))  # Get minimum EVI value over time period min_evi = evi.min_time()  # Save result output = min_evi.download(\"evi.tif\", format=\"GTiff\", options={\"compress\": \"DEFLATE\"}) <pre>Preflight process graph validation failed: [400] InvalidRequest: 1 validation error:\n  {'type': 'missing', 'loc': ('body', 'id'), 'msg': 'Field required', 'input': {'process_graph': {'loadcollection1': {'process_id': 'load_collection', 'arguments': {'bands': ['B08_10m', 'B04_10m', 'B02_10m'], 'id': 'sentinel-2-l2a', 'spatial_extent': {'west': 11.27, 'east': 11.4, 'south': 46.46, 'north': 46.52}, 'temporal_extent': ['2018-06-04', '2018-06-10'], 'width': None}}, 'reducedimension1': {'process_id': 'reduce_dimension', 'arguments': {'data': {'from_node': 'loadcollection1'}, 'dimension': 'bands', 'reducer': {'process_graph': {'arrayelement1': {'process_id': 'array_element', 'arguments': {'data': {'from_parameter': 'data'}, 'index': 0}}, 'divide1': {'process_id': 'divide', 'arguments': {'x': {'from_node': 'arrayelement1'}, 'y': 10000}}, 'arrayelement2': {'process_id': 'array_element', 'arguments': {'data': {'from_parameter': 'data'}, 'index': 1}}, 'divide2': {'process_id': 'divide', 'arguments': {'x': {'from_node': 'arrayelement2'}, 'y': 10000}}, 'subtract1': {'process_id': 'subtract', 'arguments': {'x': {'from_node': 'divide1'}, 'y': {'from_node': 'divide2'}}}, 'multiply1': {'process_id': 'multiply', 'arguments': {'x': 6, 'y': {'from_node': 'divide2'}}}, 'add1': {'process_id': 'add', 'arguments': {'x': {'from_node': 'divide1'}, 'y': {'from_node': 'multiply1'}}}, 'arrayelement3': {'process_id': 'array_element', 'arguments': {'data': {'from_parameter': 'data'}, 'index': 2}}, 'divide3': {'process_id': 'divide', 'arguments': {'x': {'from_node': 'arrayelement3'}, 'y': 10000}}, 'multiply2': {'process_id': 'multiply', 'arguments': {'x': 7.5, 'y': {'from_node': 'divide3'}}}, 'subtract2': {'process_id': 'subtract', 'arguments': {'x': {'from_node': 'add1'}, 'y': {'from_node': 'multiply2'}}}, 'add2': {'process_id': 'add', 'arguments': {'x': {'from_node': 'subtract2'}, 'y': 1}}, 'divide4': {'process_id': 'divide', 'arguments': {'x': {'from_node': 'subtract1'}, 'y': {'from_node': 'add2'}}}, 'multiply3': {'process_id': 'multiply', 'arguments': {'x': 2.5, 'y': {'from_node': 'divide4'}}, 'result': True}}}}}, 'reducedimension2': {'process_id': 'reduce_dimension', 'arguments': {'data': {'from_node': 'reducedimension1'}, 'dimension': 't', 'reducer': {'process_graph': {'min1': {'process_id': 'min', 'arguments': {'data': {'from_parameter': 'data'}}, 'result': True}}}}}, 'saveresult1': {'process_id': 'save_result', 'arguments': {'data': {'from_node': 'reducedimension2'}, 'format': 'GTiff', 'options': {'compress': 'DEFLATE'}}, 'result': True}}}}\n\n  File \"/home/emathot/Workspace/DevelopmentSeed/titiler-openeo/./titiler/openeo/factory.py\", line 747, in validate_process_graph\n    POST /validation\n</pre> In\u00a0[15]: Copied! <pre># Read the saved GeoTIFF file\nwith rasterio.open(\"evi.tif\") as src:\n    evi_data = src.read(1)\n\n# Create custom colormap for EVI\ncolors = [\"#440154\", \"#414487\", \"#2a788e\", \"#22a884\", \"#7ad151\", \"#fde725\"]\nn_bins = 100\ncmap = LinearSegmentedColormap.from_list(\"custom_evi\", colors, N=n_bins)\n\n# Create figure\nplt.figure(figsize=(12, 8))\nim = plt.imshow(evi_data, cmap=cmap, vmin=-1, vmax=1)\nplt.colorbar(im, label=\"EVI\")\nplt.title(\"Enhanced Vegetation Index (EVI)\")\nplt.axis(\"off\")\nplt.show()\n</pre> # Read the saved GeoTIFF file with rasterio.open(\"evi.tif\") as src:     evi_data = src.read(1)  # Create custom colormap for EVI colors = [\"#440154\", \"#414487\", \"#2a788e\", \"#22a884\", \"#7ad151\", \"#fde725\"] n_bins = 100 cmap = LinearSegmentedColormap.from_list(\"custom_evi\", colors, N=n_bins)  # Create figure plt.figure(figsize=(12, 8)) im = plt.imshow(evi_data, cmap=cmap, vmin=-1, vmax=1) plt.colorbar(im, label=\"EVI\") plt.title(\"Enhanced Vegetation Index (EVI)\") plt.axis(\"off\") plt.show()"},{"location":"notebooks/evi/#enhanced-vegetation-index-evi","title":"Enhanced Vegetation Index (EVI)\u00b6","text":"<p>The Enhanced Vegetation Index (EVI) is an optimized vegetation index designed to enhance the vegetation signal with improved sensitivity in high biomass regions. It was developed as an alternative to NDVI to correct for some atmospheric influences and canopy background signals.</p>"},{"location":"notebooks/evi/#key-features-of-evi","title":"Key Features of EVI:\u00b6","text":"<ul> <li>Range: -1 to +1 (like NDVI)</li> <li>More sensitive to variations in dense vegetation</li> <li>Reduces atmospheric influences</li> <li>Corrects for canopy background signals</li> </ul>"},{"location":"notebooks/evi/#evi-formula","title":"EVI Formula:\u00b6","text":"<pre><code>EVI = G * ((NIR - RED) / (NIR + C1 * RED - C2 * BLUE + L))\n</code></pre> <p>where:</p> <ul> <li>G = 2.5 (gain factor)</li> <li>C1 = 6 (atmospheric resistance red coefficient)</li> <li>C2 = 7.5 (atmospheric resistance blue coefficient)</li> <li>L = 1 (canopy background adjustment)</li> <li>NIR = Near-infrared reflectance</li> <li>RED = Red reflectance</li> <li>BLUE = Blue reflectance</li> </ul>"},{"location":"notebooks/evi/#import-required-libraries","title":"Import Required Libraries\u00b6","text":"<p>We begin by importing the necessary Python libraries for data processing and visualization.</p>"},{"location":"notebooks/evi/#connect-to-openeo-backend","title":"Connect to OpenEO Backend\u00b6","text":"<p>Connect to the OpenEO backend service which provides access to Sentinel-2 satellite imagery.</p>"},{"location":"notebooks/evi/#set-up-data-collection","title":"Set Up Data Collection\u00b6","text":"<p>We'll use Sentinel-2 Level 2A data, which provides surface reflectance values. The area of interest is in the South Tyrol region of Italy.</p> <p>Required bands:</p> <ul> <li>B02 (Blue): 490nm</li> <li>B04 (Red): 665nm</li> <li>B08 (NIR): 842nm</li> </ul>"},{"location":"notebooks/evi/#compute-evi","title":"Compute EVI\u00b6","text":"<p>Now we'll calculate the EVI using the formula: EVI = 2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))</p> <p>The resulting index values will range from -1 to +1, where:</p> <ul> <li>Higher values (0.4-0.9): Dense vegetation</li> <li>Medium values (0.2-0.4): Moderate vegetation</li> <li>Lower values (&lt;0.2): Sparse or no vegetation</li> <li>Negative values: Usually water, snow, or clouds</li> </ul>"},{"location":"notebooks/evi/#visualize-evi-results","title":"Visualize EVI Results\u00b6","text":"<p>Let's create a visualization of the EVI results using a green color scale. The color scheme will help interpret vegetation density, with darker greens representing higher EVI values.</p>"},{"location":"notebooks/evi/#interpreting-the-results","title":"Interpreting the Results\u00b6","text":"<p>The visualization shows EVI values across the study area where:</p> <ul> <li>Yellow/Light green (0.4 to 1.0): Areas of dense, healthy vegetation</li> <li>Medium green (0.2 to 0.4): Areas with moderate vegetation cover</li> <li>Blue/Purple (-1.0 to 0.2): Areas with sparse vegetation, bare soil, or water</li> </ul> <p>The EVI is particularly useful for:</p> <ol> <li>Monitoring vegetation health and density</li> <li>Detecting seasonal changes in vegetation</li> <li>Identifying agricultural areas and forest cover</li> <li>Assessing biomass and crop conditions</li> </ol>"},{"location":"notebooks/manhattan/","title":"Manhattan Satellite Imagery Analysis with OpenEO","text":"In\u00a0[1]: Copied! <pre># Import required packages\n\nimport openeo\nfrom openeo.processes import process\nfrom IPython.display import Image\n</pre> # Import required packages  import openeo from openeo.processes import process from IPython.display import Image In\u00a0[2]: Copied! <pre># Connect to the back-end\n\n# connection = openeo.connect(\"https://openeo.ds.io\").authenticate_oidc_authorization_code()\nconnection = openeo.connect(\n    url=\"http://127.0.0.1:8081/\"\n).authenticate_oidc_authorization_code()\n</pre> # Connect to the back-end  # connection = openeo.connect(\"https://openeo.ds.io\").authenticate_oidc_authorization_code() connection = openeo.connect(     url=\"http://127.0.0.1:8081/\" ).authenticate_oidc_authorization_code() In\u00a0[3]: Copied! <pre>spatial_extent_east = -73.90\nspatial_extent_north = 40.80\nspatial_extent_south = 40.70\nspatial_extent_west = -74.00\n</pre> spatial_extent_east = -73.90 spatial_extent_north = 40.80 spatial_extent_south = 40.70 spatial_extent_west = -74.00 In\u00a0[4]: Copied! <pre>load1 = connection.datacube_from_process(\n    \"load_collection\",\n    id=\"sentinel-2-global-mosaics\",\n    bands=[\"B04\", \"B03\", \"B02\"],\n    properties={},\n    spatial_extent={\n        \"east\": spatial_extent_east,\n        \"north\": spatial_extent_north,\n        \"south\": spatial_extent_south,\n        \"west\": spatial_extent_west,\n    },\n    temporal_extent=[\"2022-04-15T00:00:00Z\", \"2022-12-31T00:00:00Z\"],\n)\nload1 = load1.reduce_dimension(\n    dimension=\"time\",\n    reducer=\"first\",\n)\n</pre> load1 = connection.datacube_from_process(     \"load_collection\",     id=\"sentinel-2-global-mosaics\",     bands=[\"B04\", \"B03\", \"B02\"],     properties={},     spatial_extent={         \"east\": spatial_extent_east,         \"north\": spatial_extent_north,         \"south\": spatial_extent_south,         \"west\": spatial_extent_west,     },     temporal_extent=[\"2022-04-15T00:00:00Z\", \"2022-12-31T00:00:00Z\"], ) load1 = load1.reduce_dimension(     dimension=\"time\",     reducer=\"first\", ) In\u00a0[5]: Copied! <pre>def process1(x, context=None):\n    data1 = process(\n        \"linear_scale_range\", inputMax=10000, inputMin=0, outputMax=255, x=x\n    )\n    data2 = process(\"trunc\", x=data1)\n    return data2\n</pre> def process1(x, context=None):     data1 = process(         \"linear_scale_range\", inputMax=10000, inputMin=0, outputMax=255, x=x     )     data2 = process(\"trunc\", x=data1)     return data2 In\u00a0[6]: Copied! <pre>processed = load1.apply(process=process1)\n\ncolor = processed.process(\n    \"color_formula\",\n    data=processed,\n    formula=\"Gamma RGB 1.5 Sigmoidal RGB 6 0.3 Saturation 1\",\n)\n</pre> processed = load1.apply(process=process1)  color = processed.process(     \"color_formula\",     data=processed,     formula=\"Gamma RGB 1.5 Sigmoidal RGB 6 0.3 Saturation 1\", ) In\u00a0[7]: Copied! <pre>save5 = color.save_result(format=\"PNG\")\n\n# The process can be executed synchronously (see below), as batch job or as web service now\nresult = connection.download(save5)\nImage(result)\n</pre> save5 = color.save_result(format=\"PNG\")  # The process can be executed synchronously (see below), as batch job or as web service now result = connection.download(save5) Image(result) <pre>Preflight process graph validation failed: [400] InvalidRequest: 1 validation error:\n  {'type': 'missing', 'loc': ('body', 'id'), 'msg': 'Field required', 'input': {'process_graph': {'loadcollection1': {'process_id': 'load_collection', 'arguments': {'bands': ['B04', 'B03', 'B02'], 'id': 'sentinel-2-global-mosaics', 'properties': {}, 'spatial_extent': {'east': -73.9, 'north': 40.8, 'south': 40.7, 'west': -74.0}, 'temporal_extent': ['2022-04-15T00:00:00Z', '2022-12-31T00:00:00Z']}}, 'reducedimension1': {'process_id': 'reduce_dimension', 'arguments': {'data': {'from_node': 'loadcollection1'}, 'dimension': 'time', 'reducer': {'process_graph': {'first1': {'process_id': 'first', 'arguments': {'data': {'from_parameter': 'data'}}, 'result': True}}}}}, 'apply1': {'process_id': 'apply', 'arguments': {'data': {'from_node': 'reducedimension1'}, 'process': {'process_graph': {'linearscalerange1': {'process_id': 'linear_scale_range', 'arguments': {'inputMax': 10000, 'inputMin': 0, 'outputMax': 255, 'x': {'from_parameter': 'x'}}}, 'trunc1': {'process_id': 'trunc', 'arguments': {'x': {'from_node': 'linearscalerange1'}}, 'result': True}}}}}, 'colorformula1': {'process_id': 'color_formula', 'arguments': {'data': {'from_node': 'apply1'}, 'formula': 'Gamma RGB 1.5 Sigmoidal RGB 6 0.3 Saturation 1'}}, 'saveresult1': {'process_id': 'save_result', 'arguments': {'data': {'from_node': 'colorformula1'}, 'format': 'PNG', 'options': {}}, 'result': True}}}}\n\n  File \"/home/emathot/Workspace/DevelopmentSeed/titiler-openeo/./titiler/openeo/factory.py\", line 747, in validate_process_graph\n    POST /validation\n</pre> <pre>Preflight process graph validation failed: [400] InvalidRequest: 1 validation error:\n  {'type': 'missing', 'loc': ('body', 'id'), 'msg': 'Field required', 'input': {'process_graph': {'loadcollection1': {'process_id': 'load_collection', 'arguments': {'bands': ['B04', 'B03', 'B02'], 'id': 'sentinel-2-global-mosaics', 'properties': {}, 'spatial_extent': {'east': -73.9, 'north': 40.8, 'south': 40.7, 'west': -74.0}, 'temporal_extent': ['2022-04-15T00:00:00Z', '2022-12-31T00:00:00Z']}}, 'reducedimension1': {'process_id': 'reduce_dimension', 'arguments': {'data': {'from_node': 'loadcollection1'}, 'dimension': 'time', 'reducer': {'process_graph': {'first1': {'process_id': 'first', 'arguments': {'data': {'from_parameter': 'data'}}, 'result': True}}}}}, 'apply1': {'process_id': 'apply', 'arguments': {'data': {'from_node': 'reducedimension1'}, 'process': {'process_graph': {'linearscalerange1': {'process_id': 'linear_scale_range', 'arguments': {'inputMax': 10000, 'inputMin': 0, 'outputMax': 255, 'x': {'from_parameter': 'x'}}}, 'trunc1': {'process_id': 'trunc', 'arguments': {'x': {'from_node': 'linearscalerange1'}}, 'result': True}}}}}, 'colorformula1': {'process_id': 'color_formula', 'arguments': {'data': {'from_node': 'apply1'}, 'formula': 'Gamma RGB 1.5 Sigmoidal RGB 6 0.3 Saturation 1'}}, 'saveresult1': {'process_id': 'save_result', 'arguments': {'data': {'from_node': 'colorformula1'}, 'format': 'PNG', 'options': {}}, 'result': True}}}}\n\n  File \"/home/emathot/Workspace/DevelopmentSeed/titiler-openeo/./titiler/openeo/factory.py\", line 747, in validate_process_graph\n    POST /validation\n</pre> Out[7]:"},{"location":"notebooks/manhattan/#manhattan-satellite-imagery-analysis-with-openeo","title":"Manhattan Satellite Imagery Analysis with OpenEO\u00b6","text":""},{"location":"notebooks/manhattan/#overview","title":"Overview\u00b6","text":"<p>This notebook demonstrates how to retrieve and visualize satellite imagery of Manhattan using the OpenEO API. We'll use Sentinel-2 data to create a true-color RGB image of the Manhattan area.</p>"},{"location":"notebooks/manhattan/#connect-to-the-openeo-backend","title":"Connect to the OpenEO Backend\u00b6","text":"<p>We connect to the OpenEO backend service and authenticate using OpenID Connect. This establishes a connection to the remote processing service where our satellite data is stored.</p>"},{"location":"notebooks/manhattan/#define-spatial-extent","title":"Define Spatial Extent\u00b6","text":"<p>We define the geographic boundaries of our area of interest using longitude and latitude coordinates. This bounding box covers the Manhattan island area of New York City.</p>"},{"location":"notebooks/manhattan/#load-sentinel-2-data","title":"Load Sentinel-2 Data\u00b6","text":"<p>We load Sentinel-2 satellite imagery for our defined area using the <code>load_collection_and_reduce</code> process.</p> <ul> <li>We select the RGB bands (B04=Red, B03=Green, B02=Blue) for true-color visualization</li> <li>The temporal extent covers April to December 2022</li> <li>The \"first\" pixel selection method means we'll use the first available cloud-free pixel in the time range</li> </ul>"},{"location":"notebooks/manhattan/#scale-image-values","title":"Scale Image Values\u00b6","text":"<p>Raw satellite reflectance values need to be scaled to standard RGB display range (0-255). We define a processing function that:</p> <ol> <li>Scales the values from their original range (0-10000) to 0-255</li> <li>Applies truncation to ensure all values are valid integers within range</li> </ol>"},{"location":"notebooks/manhattan/#apply-processing-and-enhance-visual-appearance","title":"Apply Processing and Enhance Visual Appearance\u00b6","text":"<p>We apply the scaling function to our data cube, then use a color formula to enhance the visual appearance of the image. The color formula applies:</p> <ul> <li>Gamma correction (RGB 1.5) to adjust brightness and contrast</li> <li>Sigmoidal contrast enhancement (RGB 10 0.3) to improve detail visibility</li> <li>Saturation adjustment to enhance color vibrancy</li> </ul>"},{"location":"notebooks/manhattan/#save-and-display-result","title":"Save and Display Result\u00b6","text":"<p>Finally, we save the processed image as a PNG file and display it. This shows the true-color satellite view of Manhattan and surrounding areas.</p>"},{"location":"notebooks/manhattan/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates how to use OpenEO to access, process, and visualize satellite imagery for urban areas. The workflow can be extended to include additional analysis, such as:</p> <ul> <li>Time series analysis to observe changes over multiple dates</li> <li>Land cover classification to identify different urban features</li> <li>Spectral indices to analyze vegetation, water, or built-up areas</li> <li>Image segmentation to extract specific features</li> </ul>"},{"location":"notebooks/ndvi_time_series/","title":"NDVI Time Series Analysis with OpenEO","text":"In\u00a0[103]: Copied! <pre>import json\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n</pre> import json  import pandas as pd import matplotlib.pyplot as plt In\u00a0[104]: Copied! <pre>import openeo\n\n# connection = openeo.connect(\n#     url=\"https://openeo.ds.io\"\n# ).authenticate_oidc_authorization_code()\n\nconnection = openeo.connect(\n    url=\"http://127.0.0.1:8081/\"\n).authenticate_oidc_authorization_code()\n</pre> import openeo  # connection = openeo.connect( #     url=\"https://openeo.ds.io\" # ).authenticate_oidc_authorization_code()  connection = openeo.connect(     url=\"http://127.0.0.1:8081/\" ).authenticate_oidc_authorization_code() In\u00a0[105]: Copied! <pre>fields = json.loads(\n    \"\"\"{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.055945487931457, 51.222709834076504], [5.064972484168688, 51.221122565090525], [5.064972484168688, 51.221122565090525], [5.067474954083448, 51.218249806779134], [5.064827929485983, 51.21689628072789], [5.05917785594747, 51.217191909908095], [5.053553857094518, 51.21807492332223], [5.055945487931457, 51.222709834076504]]]}},\n        {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.063345886679116, 51.23087606640057], [5.06604742694687, 51.22886710731809], [5.070627820472246, 51.22874440121892], [5.068403609708207, 51.22657208381529], [5.064823257492447, 51.22676051738515], [5.064892324615199, 51.2283032878514], [5.063641745941974, 51.2285757299238], [5.062340811262595, 51.227722351687945], [5.06076005158084, 51.228042312276536], [5.063345886679116, 51.23087606640057]]]}},\n        {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.07163184674986, 51.23481147556147], [5.076706025697324, 51.23317590781036], [5.077828303041866, 51.233226237184724], [5.078024733866917, 51.23263978271262], [5.080771081607657, 51.23259097170763], [5.083734842574312, 51.23530464074437], [5.080957826735458, 51.23646091560258], [5.079752631651647, 51.23519531038643], [5.077238400183506, 51.23490534677628], [5.072856439300575, 51.23593546777778], [5.07163184674986, 51.23481147556147]]]}},\n        {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.083897244679042, 51.23510639883143], [5.081302408741335, 51.232922477780846], [5.082963802194108, 51.233146058575876], [5.084497702305552, 51.232672717580655], [5.085732850338428, 51.2340852086282], [5.083897244679042, 51.23510639883143]]]}}\n    ]}\n\"\"\"\n)\n</pre> fields = json.loads(     \"\"\"{     \"type\": \"FeatureCollection\",     \"features\": [         {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.055945487931457, 51.222709834076504], [5.064972484168688, 51.221122565090525], [5.064972484168688, 51.221122565090525], [5.067474954083448, 51.218249806779134], [5.064827929485983, 51.21689628072789], [5.05917785594747, 51.217191909908095], [5.053553857094518, 51.21807492332223], [5.055945487931457, 51.222709834076504]]]}},         {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.063345886679116, 51.23087606640057], [5.06604742694687, 51.22886710731809], [5.070627820472246, 51.22874440121892], [5.068403609708207, 51.22657208381529], [5.064823257492447, 51.22676051738515], [5.064892324615199, 51.2283032878514], [5.063641745941974, 51.2285757299238], [5.062340811262595, 51.227722351687945], [5.06076005158084, 51.228042312276536], [5.063345886679116, 51.23087606640057]]]}},         {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.07163184674986, 51.23481147556147], [5.076706025697324, 51.23317590781036], [5.077828303041866, 51.233226237184724], [5.078024733866917, 51.23263978271262], [5.080771081607657, 51.23259097170763], [5.083734842574312, 51.23530464074437], [5.080957826735458, 51.23646091560258], [5.079752631651647, 51.23519531038643], [5.077238400183506, 51.23490534677628], [5.072856439300575, 51.23593546777778], [5.07163184674986, 51.23481147556147]]]}},         {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[5.083897244679042, 51.23510639883143], [5.081302408741335, 51.232922477780846], [5.082963802194108, 51.233146058575876], [5.084497702305552, 51.232672717580655], [5.085732850338428, 51.2340852086282], [5.083897244679042, 51.23510639883143]]]}}     ]} \"\"\" ) In\u00a0[106]: Copied! <pre>s2cube = connection.load_collection(\n    \"sentinel-2-l2a\",\n    temporal_extent=[\"2020-04-01\", \"2020-10-01\"],\n    spatial_extent={\"west\": 5.05, \"south\": 51.21, \"east\": 5.09, \"north\": 51.24},\n    bands=[\"B04_10m\", \"B08_10m\"],\n    max_cloud_cover=20,\n)\n\n# Extract individual bands\nred = s2cube.band(\"B04_10m\")\nnir = s2cube.band(\"B08_10m\")\n\n# Calculate NDVI using the formula: (NIR - Red) / (NIR + Red)\nndvi = (nir - red) / (nir + red)\n</pre> s2cube = connection.load_collection(     \"sentinel-2-l2a\",     temporal_extent=[\"2020-04-01\", \"2020-10-01\"],     spatial_extent={\"west\": 5.05, \"south\": 51.21, \"east\": 5.09, \"north\": 51.24},     bands=[\"B04_10m\", \"B08_10m\"],     max_cloud_cover=20, )  # Extract individual bands red = s2cube.band(\"B04_10m\") nir = s2cube.band(\"B08_10m\")  # Calculate NDVI using the formula: (NIR - Red) / (NIR + Red) ndvi = (nir - red) / (nir + red) <pre>/home/emathot/Workspace/DevelopmentSeed/titiler-openeo/.venv/lib/python3.10/site-packages/openeo/rest/connection.py:1238: UserWarning: Property filtering with unsupported properties according to collection/STAC metadata: {'eo:cloud_cover'} (supported: dict_keys(['gsd', 'platform', 'instruments', 'product:type', 'constellation', 'processing:level', 'product:timeliness', 'product:timeliness_category', 'sat:platform_international_designator', 'statistics'])).\n  return DataCube.load_collection(\n</pre> In\u00a0[107]: Copied! <pre>timeseries = ndvi.aggregate_spatial(geometries=fields, reducer=\"mean\")\n</pre> timeseries = ndvi.aggregate_spatial(geometries=fields, reducer=\"mean\") In\u00a0[108]: Copied! <pre>timeseries.download(\"timeseries-basic.csv\", format=\"csv\")\npd.read_csv(\"timeseries-basic.csv\", index_col=0).head()\n</pre> timeseries.download(\"timeseries-basic.csv\", format=\"csv\") pd.read_csv(\"timeseries-basic.csv\", index_col=0).head() <pre>Preflight process graph validation failed: [400] InvalidRequest: 1 validation error:\n  {'type': 'missing', 'loc': ('body', 'id'), 'msg': 'Field required', 'input': {'process_graph': {'loadcollection1': {'process_id': 'load_collection', 'arguments': {'bands': ['B04_10m', 'B08_10m'], 'id': 'sentinel-2-l2a', 'properties': {'eo:cloud_cover': {'process_graph': {'lte1': {'process_id': 'lte', 'arguments': {'x': {'from_parameter': 'value'}, 'y': 20}, 'result': True}}}}, 'spatial_extent': {'west': 5.05, 'south': 51.21, 'east': 5.09, 'north': 51.24}, 'temporal_extent': ['2020-04-01', '2020-10-01']}}, 'reducedimension1': {'process_id': 'reduce_dimension', 'arguments': {'data': {'from_node': 'loadcollection1'}, 'dimension': 'spectral', 'reducer': {'process_graph': {'arrayelement1': {'process_id': 'array_element', 'arguments': {'data': {'from_parameter': 'data'}, 'index': 1}}, 'arrayelement2': {'process_id': 'array_element', 'arguments': {'data': {'from_parameter': 'data'}, 'index': 0}}, 'subtract1': {'process_id': 'subtract', 'arguments': {'x': {'from_node': 'arrayelement1'}, 'y': {'from_node': 'arrayelement2'}}}, 'add1': {'process_id': 'add', 'arguments': {'x': {'from_node': 'arrayelement1'}, 'y': {'from_node': 'arrayelement2'}}}, 'divide1': {'process_id': 'divide', 'arguments': {'x': {'from_node': 'subtract1'}, 'y': {'from_node': 'add1'}}, 'result': True}}}}}, 'aggregatespatial1': {'process_id': 'aggregate_spatial', 'arguments': {'data': {'from_node': 'reducedimension1'}, 'geometries': {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'properties': {}, 'geometry': {'type': 'Polygon', 'coordinates': [[[5.055945487931457, 51.222709834076504], [5.064972484168688, 51.221122565090525], [5.064972484168688, 51.221122565090525], [5.067474954083448, 51.218249806779134], [5.064827929485983, 51.21689628072789], [5.05917785594747, 51.217191909908095], [5.053553857094518, 51.21807492332223], [5.055945487931457, 51.222709834076504]]]}}, {'type': 'Feature', 'properties': {}, 'geometry': {'type': 'Polygon', 'coordinates': [[[5.063345886679116, 51.23087606640057], [5.06604742694687, 51.22886710731809], [5.070627820472246, 51.22874440121892], [5.068403609708207, 51.22657208381529], [5.064823257492447, 51.22676051738515], [5.064892324615199, 51.2283032878514], [5.063641745941974, 51.2285757299238], [5.062340811262595, 51.227722351687945], [5.06076005158084, 51.228042312276536], [5.063345886679116, 51.23087606640057]]]}}, {'type': 'Feature', 'properties': {}, 'geometry': {'type': 'Polygon', 'coordinates': [[[5.07163184674986, 51.23481147556147], [5.076706025697324, 51.23317590781036], [5.077828303041866, 51.233226237184724], [5.078024733866917, 51.23263978271262], [5.080771081607657, 51.23259097170763], [5.083734842574312, 51.23530464074437], [5.080957826735458, 51.23646091560258], [5.079752631651647, 51.23519531038643], [5.077238400183506, 51.23490534677628], [5.072856439300575, 51.23593546777778], [5.07163184674986, 51.23481147556147]]]}}, {'type': 'Feature', 'properties': {}, 'geometry': {'type': 'Polygon', 'coordinates': [[[5.083897244679042, 51.23510639883143], [5.081302408741335, 51.232922477780846], [5.082963802194108, 51.233146058575876], [5.084497702305552, 51.232672717580655], [5.085732850338428, 51.2340852086282], [5.083897244679042, 51.23510639883143]]]}}]}, 'reducer': {'process_graph': {'mean1': {'process_id': 'mean', 'arguments': {'data': {'from_parameter': 'data'}}, 'result': True}}}}}, 'saveresult1': {'process_id': 'save_result', 'arguments': {'data': {'from_node': 'aggregatespatial1'}, 'format': 'csv', 'options': {}}, 'result': True}}}}\n\n  File \"/home/emathot/Workspace/DevelopmentSeed/titiler-openeo/./titiler/openeo/factory.py\", line 747, in validate_process_graph\n    POST /validation\n</pre> Out[108]: feature_index value date 2020-09-22T10:46:49.025000+00:00 0 0.428455 2020-09-19T10:36:49.024000+00:00 0 0.425533 2020-09-17T10:50:31.024000+00:00 0 0.420721 2020-09-14T10:40:31.024000+00:00 0 0.395685 2020-09-12T10:46:29.024000+00:00 0 0.376593 In\u00a0[109]: Copied! <pre>def plot_timeseries(filename, figsize=(6, 3)):\n    \"\"\"Plot NDVI time series from a CSV file\n\n    Parameters:\n    ----------\n    filename : str\n        Path to the CSV file containing time series data\n    figsize : tuple, optional\n        Figure size as (width, height) in inches\n    \"\"\"\n    df = pd.read_csv(filename, index_col=0)\n    df.index = pd.to_datetime(df.index)  # Convert index to datetime format\n\n    fig, ax = plt.subplots(figsize=figsize, dpi=90)\n    df.groupby(\"feature_index\")[\"value\"].plot(marker=\"o\", ax=ax)\n    ax.set_title(filename.split(\"/\")[-1])\n    ax.set_ylabel(\"NDVI\")\n    ax.set_ylim(0, 1)  # NDVI typically ranges from 0 to 1 for vegetation\n    ax.legend(title=\"parcel id\", loc=\"lower left\", ncol=2)\n\n\nplot_timeseries(\"timeseries-basic.csv\")\n</pre> def plot_timeseries(filename, figsize=(6, 3)):     \"\"\"Plot NDVI time series from a CSV file      Parameters:     ----------     filename : str         Path to the CSV file containing time series data     figsize : tuple, optional         Figure size as (width, height) in inches     \"\"\"     df = pd.read_csv(filename, index_col=0)     df.index = pd.to_datetime(df.index)  # Convert index to datetime format      fig, ax = plt.subplots(figsize=figsize, dpi=90)     df.groupby(\"feature_index\")[\"value\"].plot(marker=\"o\", ax=ax)     ax.set_title(filename.split(\"/\")[-1])     ax.set_ylabel(\"NDVI\")     ax.set_ylim(0, 1)  # NDVI typically ranges from 0 to 1 for vegetation     ax.legend(title=\"parcel id\", loc=\"lower left\", ncol=2)   plot_timeseries(\"timeseries-basic.csv\")"},{"location":"notebooks/ndvi_time_series/#ndvi-time-series-analysis-with-openeo","title":"NDVI Time Series Analysis with OpenEO\u00b6","text":"<p>This notebook demonstrates how to extract and analyze Normalized Difference Vegetation Index (NDVI) time series for agricultural parcels using Sentinel-2 imagery and the OpenEO API.</p>"},{"location":"notebooks/ndvi_time_series/#overview","title":"Overview\u00b6","text":"<p>In this notebook, we will:</p> <ol> <li>Connect to an OpenEO backend service</li> <li>Define agricultural field geometries</li> <li>Load Sentinel-2 imagery for a specific time period</li> <li>Calculate NDVI from red and near-infrared bands</li> <li>Extract time series data by aggregating NDVI values over field geometries</li> <li>Visualize and analyze the resulting time series</li> </ol>"},{"location":"notebooks/ndvi_time_series/#what-is-ndvi","title":"What is NDVI?\u00b6","text":"<p>The Normalized Difference Vegetation Index (NDVI) is a simple but effective index for quantifying vegetation greenness. It uses the contrast between the red and near-infrared reflectance of vegetation.</p> <p>NDVI is calculated as: (NIR - Red) / (NIR + Red)</p> <p>NDVI values range from -1 to 1:</p> <ul> <li>Values around 0 typically represent non-vegetated areas (water, bare soil, buildings)</li> <li>Values between 0.2 and 0.4 represent sparse vegetation</li> <li>Values between 0.4 and 0.8 represent dense vegetation (higher values indicate healthier vegetation)</li> </ul> <p>NDVI time series are valuable for monitoring crop growth, detecting anomalies, and analyzing seasonal patterns.</p>"},{"location":"notebooks/ndvi_time_series/#import-required-libraries","title":"Import Required Libraries\u00b6","text":"<p>We begin by importing the necessary Python libraries for data processing and visualization.</p>"},{"location":"notebooks/ndvi_time_series/#connect-to-openeo-backend","title":"Connect to OpenEO Backend\u00b6","text":"<p>Connect to a local OpenEO backend running on port 8081 and authenticate using OpenID Connect.</p>"},{"location":"notebooks/ndvi_time_series/#define-field-geometries","title":"Define Field Geometries\u00b6","text":"<p>Below we define four agricultural field geometries as GeoJSON Polygons. These fields will be used to extract NDVI time series. The coordinates are in WGS84 (EPSG:4326) and represent fields near latitude 51.22\u00b0 N, longitude 5.06\u00b0 E (likely in the Netherlands or Belgium).</p>"},{"location":"notebooks/ndvi_time_series/#load-sentinel-2-data-and-calculate-ndvi","title":"Load Sentinel-2 Data and Calculate NDVI\u00b6","text":"<p>Here we load Sentinel-2 L2A data for a 2-month period (June-August 2020) covering our area of interest. We select only the red (B04) and near-infrared (B08) bands at 10m resolution, as these are needed for NDVI calculation.</p> <p>The spatial extent is defined to cover all our field geometries with a small buffer.</p>"},{"location":"notebooks/ndvi_time_series/#extract-time-series-for-each-field","title":"Extract Time Series for Each Field\u00b6","text":"<p>Now we aggregate the NDVI values spatially for each field geometry using the mean as our reducer function. This gives us the average NDVI value within each field for each available date in our time period.</p> <p>The result is a time series of NDVI values for each field.</p>"},{"location":"notebooks/ndvi_time_series/#download-and-preview-time-series-data","title":"Download and Preview Time Series Data\u00b6","text":"<p>We download the time series data as a CSV file and preview the first few rows to understand its structure.</p>"},{"location":"notebooks/ndvi_time_series/#visualize-time-series","title":"Visualize Time Series\u00b6","text":"<p>This function helps us visualize the NDVI time series for all fields. The plot shows the temporal evolution of NDVI for each field, allowing us to compare vegetation growth patterns between fields.</p>"},{"location":"notebooks/ndvi_time_series/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates a complete workflow for extracting and analyzing NDVI time series from Sentinel-2 imagery using OpenEO. The approach can be extended to:</p> <ul> <li>Analyze longer time periods to study seasonal patterns</li> <li>Include additional vegetation indices beyond NDVI</li> <li>Apply filtering or smoothing to handle noise in the time series</li> <li>Implement anomaly detection to identify unusual growth patterns</li> <li>Extract growth parameters such as start of season, peak of season, etc.</li> </ul> <p>NDVI time series analysis is valuable for a range of applications including crop monitoring, yield estimation, drought assessment, and phenological studies.</p>"},{"location":"notebooks/openeo/","title":"Openeo","text":"In\u00a0[2]: Copied! <pre>import openeo\n</pre> import openeo In\u00a0[4]: Copied! <pre>connection = openeo.connect(\"http://127.0.0.1:8080\")\nconnection\n</pre> connection = openeo.connect(\"http://127.0.0.1:8080\") connection Out[4]: <pre>&lt;Connection to 'http://127.0.0.1:8080/' with NullAuth&gt;</pre> In\u00a0[8]: Copied! <pre>collections = connection.list_collections()\ncollections\n</pre> collections = connection.list_collections() collections Out[8]: In\u00a0[\u00a0]: Copied! <pre>connection.describe_collection(collections[0][\"id\"])\n</pre> connection.describe_collection(collections[0][\"id\"]) Out[\u00a0]: In\u00a0[10]: Copied! <pre>connection.list_file_formats()\n</pre> connection.list_file_formats() Out[10]: In\u00a0[11]: Copied! <pre>connection.list_processes()\n</pre> connection.list_processes() Out[11]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}